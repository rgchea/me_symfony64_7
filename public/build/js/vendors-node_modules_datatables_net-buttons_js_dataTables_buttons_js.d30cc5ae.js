(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_datatables_net-buttons_js_dataTables_buttons_js"],{

/***/ "./node_modules/datatables.net-buttons/js/dataTables.buttons.js":
/*!**********************************************************************!*\
  !*** ./node_modules/datatables.net-buttons/js/dataTables.buttons.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Buttons for DataTables 1.7.1
 * Â©2016-2021 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( true ) {
		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.mjs")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {
			return factory( $, window, document );
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else // removed by dead control flow
{}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


// Used for namespacing events added to the document by each instance, so they
// can be removed on destroy
var _instCounter = 0;

// Button namespacing counter for namespacing events on individual buttons
var _buttonCounter = 0;

var _dtButtons = DataTable.ext.buttons;

// Allow for jQuery slim
function _fadeIn(el, duration, fn) {
	if ($.fn.animate) {
		el
			.stop()
			.fadeIn( duration, fn );
	}
	else {
		el.css('display', 'block');

		if (fn) {
			fn.call(el);
		}
	}
}

function _fadeOut(el, duration, fn) {
	if ($.fn.animate) {
		el
			.stop()
			.fadeOut( duration, fn );
	}
	else {
		el.css('display', 'none');
		
		if (fn) {
			fn.call(el);
		}
	}
}

/**
 * [Buttons description]
 * @param {[type]}
 * @param {[type]}
 */
var Buttons = function( dt, config )
{
	// If not created with a `new` keyword then we return a wrapper function that
	// will take the settings object for a DT. This allows easy use of new instances
	// with the `layout` option - e.g. `topLeft: $.fn.dataTable.Buttons( ... )`.
	if ( !(this instanceof Buttons) ) {
		return function (settings) {
			return new Buttons( settings, dt ).container();
		};
	}

	// If there is no config set it to an empty object
	if ( typeof( config ) === 'undefined' ) {
		config = {};	
	}
	
	// Allow a boolean true for defaults
	if ( config === true ) {
		config = {};
	}

	// For easy configuration of buttons an array can be given
	if ( Array.isArray( config ) ) {
		config = { buttons: config };
	}

	this.c = $.extend( true, {}, Buttons.defaults, config );

	// Don't want a deep copy for the buttons
	if ( config.buttons ) {
		this.c.buttons = config.buttons;
	}

	this.s = {
		dt: new DataTable.Api( dt ),
		buttons: [],
		listenKeys: '',
		namespace: 'dtb'+(_instCounter++)
	};

	this.dom = {
		container: $('<'+this.c.dom.container.tag+'/>')
			.addClass( this.c.dom.container.className )
	};

	this._constructor();
};


$.extend( Buttons.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 */

	/**
	 * Get the action of a button
	 * @param  {int|string} Button index
	 * @return {function}
	 *//**
	 * Set the action of a button
	 * @param  {node} node Button element
	 * @param  {function} action Function to set
	 * @return {Buttons} Self for chaining
	 */
	action: function ( node, action )
	{
		var button = this._nodeToButton( node );

		if ( action === undefined ) {
			return button.conf.action;
		}

		button.conf.action = action;

		return this;
	},

	/**
	 * Add an active class to the button to make to look active or get current
	 * active state.
	 * @param  {node} node Button element
	 * @param  {boolean} [flag] Enable / disable flag
	 * @return {Buttons} Self for chaining or boolean for getter
	 */
	active: function ( node, flag ) {
		var button = this._nodeToButton( node );
		var klass = this.c.dom.button.active;
		var jqNode = $(button.node);

		if ( flag === undefined ) {
			return jqNode.hasClass( klass );
		}

		jqNode.toggleClass( klass, flag === undefined ? true : flag );

		return this;
	},

	/**
	 * Add a new button
	 * @param {object} config Button configuration object, base string name or function
	 * @param {int|string} [idx] Button index for where to insert the button
	 * @return {Buttons} Self for chaining
	 */
	add: function ( config, idx )
	{
		var buttons = this.s.buttons;

		if ( typeof idx === 'string' ) {
			var split = idx.split('-');
			var base = this.s;

			for ( var i=0, ien=split.length-1 ; i<ien ; i++ ) {
				base = base.buttons[ split[i]*1 ];
			}

			buttons = base.buttons;
			idx = split[ split.length-1 ]*1;
		}

		this._expandButton( buttons, config, base !== undefined, idx );
		this._draw();

		return this;
	},

	/**
	 * Get the container node for the buttons
	 * @return {jQuery} Buttons node
	 */
	container: function ()
	{
		return this.dom.container;
	},

	/**
	 * Disable a button
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	disable: function ( node ) {
		var button = this._nodeToButton( node );

		$(button.node)
			.addClass( this.c.dom.button.disabled )
			.attr('disabled', true);

		return this;
	},

	/**
	 * Destroy the instance, cleaning up event handlers and removing DOM
	 * elements
	 * @return {Buttons} Self for chaining
	 */
	destroy: function ()
	{
		// Key event listener
		$('body').off( 'keyup.'+this.s.namespace );

		// Individual button destroy (so they can remove their own events if
		// needed). Take a copy as the array is modified by `remove`
		var buttons = this.s.buttons.slice();
		var i, ien;
		
		for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
			this.remove( buttons[i].node );
		}

		// Container
		this.dom.container.remove();

		// Remove from the settings object collection
		var buttonInsts = this.s.dt.settings()[0];

		for ( i=0, ien=buttonInsts.length ; i<ien ; i++ ) {
			if ( buttonInsts.inst === this ) {
				buttonInsts.splice( i, 1 );
				break;
			}
		}

		return this;
	},

	/**
	 * Enable / disable a button
	 * @param  {node} node Button node
	 * @param  {boolean} [flag=true] Enable / disable flag
	 * @return {Buttons} Self for chaining
	 */
	enable: function ( node, flag )
	{
		if ( flag === false ) {
			return this.disable( node );
		}

		var button = this._nodeToButton( node );
		$(button.node)
			.removeClass( this.c.dom.button.disabled )
			.removeAttr('disabled');

		return this;
	},

	/**
	 * Get the instance name for the button set selector
	 * @return {string} Instance name
	 */
	name: function ()
	{
		return this.c.name;
	},

	/**
	 * Get a button's node of the buttons container if no button is given
	 * @param  {node} [node] Button node
	 * @return {jQuery} Button element, or container
	 */
	node: function ( node )
	{
		if ( ! node ) {
			return this.dom.container;
		}

		var button = this._nodeToButton( node );
		return $(button.node);
	},

	/**
	 * Set / get a processing class on the selected button
	 * @param {element} node Triggering button node
	 * @param  {boolean} flag true to add, false to remove, undefined to get
	 * @return {boolean|Buttons} Getter value or this if a setter.
	 */
	processing: function ( node, flag )
	{
		var dt = this.s.dt;
		var button = this._nodeToButton( node );

		if ( flag === undefined ) {
			return $(button.node).hasClass( 'processing' );
		}

		$(button.node).toggleClass( 'processing', flag );

		$(dt.table().node()).triggerHandler( 'buttons-processing.dt', [
			flag, dt.button( node ), dt, $(node), button.conf
		] );

		return this;
	},

	/**
	 * Remove a button.
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	remove: function ( node )
	{
		var button = this._nodeToButton( node );
		var host = this._nodeToHost( node );
		var dt = this.s.dt;

		// Remove any child buttons first
		if ( button.buttons.length ) {
			for ( var i=button.buttons.length-1 ; i>=0 ; i-- ) {
				this.remove( button.buttons[i].node );
			}
		}

		// Allow the button to remove event handlers, etc
		if ( button.conf.destroy ) {
			button.conf.destroy.call( dt.button(node), dt, $(node), button.conf );
		}

		this._removeKey( button.conf );

		$(button.node).remove();

		var idx = $.inArray( button, host );
		host.splice( idx, 1 );

		return this;
	},

	/**
	 * Get the text for a button
	 * @param  {int|string} node Button index
	 * @return {string} Button text
	 *//**
	 * Set the text for a button
	 * @param  {int|string|function} node Button index
	 * @param  {string} label Text
	 * @return {Buttons} Self for chaining
	 */
	text: function ( node, label )
	{
		var button = this._nodeToButton( node );
		var buttonLiner = this.c.dom.collection.buttonLiner;
		var linerTag = button.inCollection && buttonLiner && buttonLiner.tag ?
			buttonLiner.tag :
			this.c.dom.buttonLiner.tag;
		var dt = this.s.dt;
		var jqNode = $(button.node);
		var text = function ( opt ) {
			return typeof opt === 'function' ?
				opt( dt, jqNode, button.conf ) :
				opt;
		};

		if ( label === undefined ) {
			return text( button.conf.text );
		}

		button.conf.text = label;

		if ( linerTag ) {
			jqNode.children( linerTag ).html( text(label) );
		}
		else {
			jqNode.html( text(label) );
		}

		return this;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Buttons constructor
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var dtSettings = dt.settings()[0];
		var buttons =  this.c.buttons;

		if ( ! dtSettings._buttons ) {
			dtSettings._buttons = [];
		}

		dtSettings._buttons.push( {
			inst: this,
			name: this.c.name
		} );

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			this.add( buttons[i] );
		}

		dt.on( 'destroy', function ( e, settings ) {
			if ( settings === dtSettings ) {
				that.destroy();
			}
		} );

		// Global key event binding to listen for button keys
		$('body').on( 'keyup.'+this.s.namespace, function ( e ) {
			if ( ! document.activeElement || document.activeElement === document.body ) {
				// SUse a string of characters for fast lookup of if we need to
				// handle this
				var character = String.fromCharCode(e.keyCode).toLowerCase();

				if ( that.s.listenKeys.toLowerCase().indexOf( character ) !== -1 ) {
					that._keypress( character, e );
				}
			}
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Add a new button to the key press listener
	 * @param {object} conf Resolved button configuration object
	 * @private
	 */
	_addKey: function ( conf )
	{
		if ( conf.key ) {
			this.s.listenKeys += $.isPlainObject( conf.key ) ?
				conf.key.key :
				conf.key;
		}
	},

	/**
	 * Insert the buttons into the container. Call without parameters!
	 * @param  {node} [container] Recursive only - Insert point
	 * @param  {array} [buttons] Recursive only - Buttons array
	 * @private
	 */
	_draw: function ( container, buttons )
	{
		if ( ! container ) {
			container = this.dom.container;
			buttons = this.s.buttons;
		}

		container.children().detach();

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			container.append( buttons[i].inserter );
			container.append( ' ' );

			if ( buttons[i].buttons && buttons[i].buttons.length ) {
				this._draw( buttons[i].collection, buttons[i].buttons );
			}
		}
	},

	/**
	 * Create buttons from an array of buttons
	 * @param  {array} attachTo Buttons array to attach to
	 * @param  {object} button Button definition
	 * @param  {boolean} inCollection true if the button is in a collection
	 * @private
	 */
	_expandButton: function ( attachTo, button, inCollection, attachPoint )
	{
		var dt = this.s.dt;
		var buttonCounter = 0;
		var buttons = ! Array.isArray( button ) ?
			[ button ] :
			button;

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			var conf = this._resolveExtends( buttons[i] );

			if ( ! conf ) {
				continue;
			}

			// If the configuration is an array, then expand the buttons at this
			// point
			if ( Array.isArray( conf ) ) {
				this._expandButton( attachTo, conf, inCollection, attachPoint );
				continue;
			}

			var built = this._buildButton( conf, inCollection );
			if ( ! built ) {
				continue;
			}

			if ( attachPoint !== undefined && attachPoint !== null ) {
				attachTo.splice( attachPoint, 0, built );
				attachPoint++;
			}
			else {
				attachTo.push( built );
			}

			if ( built.conf.buttons ) {
				built.collection = $('<'+this.c.dom.collection.tag+'/>');

				built.conf._collection = built.collection;

				this._expandButton( built.buttons, built.conf.buttons, true, attachPoint );
			}

			// init call is made here, rather than buildButton as it needs to
			// be selectable, and for that it needs to be in the buttons array
			if ( conf.init ) {
				conf.init.call( dt.button( built.node ), dt, $(built.node), conf );
			}

			buttonCounter++;
		}
	},

	/**
	 * Create an individual button
	 * @param  {object} config            Resolved button configuration
	 * @param  {boolean} inCollection `true` if a collection button
	 * @return {jQuery} Created button node (jQuery)
	 * @private
	 */
	_buildButton: function ( config, inCollection )
	{
		var buttonDom = this.c.dom.button;
		var linerDom = this.c.dom.buttonLiner;
		var collectionDom = this.c.dom.collection;
		var dt = this.s.dt;
		var text = function ( opt ) {
			return typeof opt === 'function' ?
				opt( dt, button, config ) :
				opt;
		};

		if ( inCollection && collectionDom.button ) {
			buttonDom = collectionDom.button;
		}

		if ( inCollection && collectionDom.buttonLiner ) {
			linerDom = collectionDom.buttonLiner;
		}

		// Make sure that the button is available based on whatever requirements
		// it has. For example, PDF button require pdfmake
		if ( config.available && ! config.available( dt, config ) ) {
			return false;
		}

		var action = function ( e, dt, button, config ) {
			config.action.call( dt.button( button ), e, dt, button, config );

			$(dt.table().node()).triggerHandler( 'buttons-action.dt', [
				dt.button( button ), dt, button, config 
			] );
		};

		var tag = config.tag || buttonDom.tag;
		var clickBlurs = config.clickBlurs === undefined ? true : config.clickBlurs
		var button = $('<'+tag+'/>')
			.addClass( buttonDom.className )
			.attr( 'tabindex', this.s.dt.settings()[0].iTabIndex )
			.attr( 'aria-controls', this.s.dt.table().node().id )
			.on( 'click.dtb', function (e) {
				e.preventDefault();

				if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
					action( e, dt, button, config );
				}
				if( clickBlurs ) {
					button.trigger('blur');
				}
			} )
			.on( 'keyup.dtb', function (e) {
				if ( e.keyCode === 13 ) {
					if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
						action( e, dt, button, config );
					}
				}
			} );

		// Make `a` tags act like a link
		if ( tag.toLowerCase() === 'a' ) {
			button.attr( 'href', '#' );
		}

		// Button tags should have `type=button` so they don't have any default behaviour
		if ( tag.toLowerCase() === 'button' ) {
			button.attr( 'type', 'button' );
		}

		if ( linerDom.tag ) {
			var liner = $('<'+linerDom.tag+'/>')
				.html( text( config.text ) )
				.addClass( linerDom.className );

			if ( linerDom.tag.toLowerCase() === 'a' ) {
				liner.attr( 'href', '#' );
			}

			button.append( liner );
		}
		else {
			button.html( text( config.text ) );
		}

		if ( config.enabled === false ) {
			button.addClass( buttonDom.disabled );
		}

		if ( config.className ) {
			button.addClass( config.className );
		}

		if ( config.titleAttr ) {
			button.attr( 'title', text( config.titleAttr ) );
		}

		if ( config.attr ) {
			button.attr( config.attr );
		}

		if ( ! config.namespace ) {
			config.namespace = '.dt-button-'+(_buttonCounter++);
		}

		var buttonContainer = this.c.dom.buttonContainer;
		var inserter;
		if ( buttonContainer && buttonContainer.tag ) {
			inserter = $('<'+buttonContainer.tag+'/>')
				.addClass( buttonContainer.className )
				.append( button );
		}
		else {
			inserter = button;
		}

		this._addKey( config );

		// Style integration callback for DOM manipulation
		// Note that this is _not_ documented. It is currently
		// for style integration only
		if( this.c.buttonCreated ) {
			inserter = this.c.buttonCreated( config, inserter );
		}

		return {
			conf:         config,
			node:         button.get(0),
			inserter:     inserter,
			buttons:      [],
			inCollection: inCollection,
			collection:   null
		};
	},

	/**
	 * Get the button object from a node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {object} Button object
	 * @private
	 */
	_nodeToButton: function ( node, buttons )
	{
		if ( ! buttons ) {
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			if ( buttons[i].node === node ) {
				return buttons[i];
			}

			if ( buttons[i].buttons.length ) {
				var ret = this._nodeToButton( node, buttons[i].buttons );

				if ( ret ) {
					return ret;
				}
			}
		}
	},

	/**
	 * Get container array for a button from a button node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {array} Button's host array
	 * @private
	 */
	_nodeToHost: function ( node, buttons )
	{
		if ( ! buttons ) {
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			if ( buttons[i].node === node ) {
				return buttons;
			}

			if ( buttons[i].buttons.length ) {
				var ret = this._nodeToHost( node, buttons[i].buttons );

				if ( ret ) {
					return ret;
				}
			}
		}
	},

	/**
	 * Handle a key press - determine if any button's key configured matches
	 * what was typed and trigger the action if so.
	 * @param  {string} character The character pressed
	 * @param  {object} e Key event that triggered this call
	 * @private
	 */
	_keypress: function ( character, e )
	{
		// Check if this button press already activated on another instance of Buttons
		if ( e._buttonsHandled ) {
			return;
		}

		var run = function ( conf, node ) {
			if ( ! conf.key ) {
				return;
			}

			if ( conf.key === character ) {
				e._buttonsHandled = true;
				$(node).click();
			}
			else if ( $.isPlainObject( conf.key ) ) {
				if ( conf.key.key !== character ) {
					return;
				}

				if ( conf.key.shiftKey && ! e.shiftKey ) {
					return;
				}

				if ( conf.key.altKey && ! e.altKey ) {
					return;
				}

				if ( conf.key.ctrlKey && ! e.ctrlKey ) {
					return;
				}

				if ( conf.key.metaKey && ! e.metaKey ) {
					return;
				}

				// Made it this far - it is good
				e._buttonsHandled = true;
				$(node).click();
			}
		};

		var recurse = function ( a ) {
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				run( a[i].conf, a[i].node );

				if ( a[i].buttons.length ) {
					recurse( a[i].buttons );
				}
			}
		};

		recurse( this.s.buttons );
	},

	/**
	 * Remove a key from the key listener for this instance (to be used when a
	 * button is removed)
	 * @param  {object} conf Button configuration
	 * @private
	 */
	_removeKey: function ( conf )
	{
		if ( conf.key ) {
			var character = $.isPlainObject( conf.key ) ?
				conf.key.key :
				conf.key;

			// Remove only one character, as multiple buttons could have the
			// same listening key
			var a = this.s.listenKeys.split('');
			var idx = $.inArray( character, a );
			a.splice( idx, 1 );
			this.s.listenKeys = a.join('');
		}
	},

	/**
	 * Resolve a button configuration
	 * @param  {string|function|object} conf Button config to resolve
	 * @return {object} Button configuration
	 * @private
	 */
	_resolveExtends: function ( conf )
	{
		var dt = this.s.dt;
		var i, ien;
		var toConfObject = function ( base ) {
			var loop = 0;

			// Loop until we have resolved to a button configuration, or an
			// array of button configurations (which will be iterated
			// separately)
			while ( ! $.isPlainObject(base) && ! Array.isArray(base) ) {
				if ( base === undefined ) {
					return;
				}

				if ( typeof base === 'function' ) {
					base = base( dt, conf );

					if ( ! base ) {
						return false;
					}
				}
				else if ( typeof base === 'string' ) {
					if ( ! _dtButtons[ base ] ) {
						throw 'Unknown button type: '+base;
					}

					base = _dtButtons[ base ];
				}

				loop++;
				if ( loop > 30 ) {
					// Protect against misconfiguration killing the browser
					throw 'Buttons: Too many iterations';
				}
			}

			return Array.isArray( base ) ?
				base :
				$.extend( {}, base );
		};

		conf = toConfObject( conf );

		while ( conf && conf.extend ) {
			// Use `toConfObject` in case the button definition being extended
			// is itself a string or a function
			if ( ! _dtButtons[ conf.extend ] ) {
				throw 'Cannot extend unknown button type: '+conf.extend;
			}

			var objArray = toConfObject( _dtButtons[ conf.extend ] );
			if ( Array.isArray( objArray ) ) {
				return objArray;
			}
			else if ( ! objArray ) {
				// This is a little brutal as it might be possible to have a
				// valid button without the extend, but if there is no extend
				// then the host button would be acting in an undefined state
				return false;
			}

			// Stash the current class name
			var originalClassName = objArray.className;

			conf = $.extend( {}, objArray, conf );

			// The extend will have overwritten the original class name if the
			// `conf` object also assigned a class, but we want to concatenate
			// them so they are list that is combined from all extended buttons
			if ( originalClassName && conf.className !== originalClassName ) {
				conf.className = originalClassName+' '+conf.className;
			}

			// Buttons to be added to a collection  -gives the ability to define
			// if buttons should be added to the start or end of a collection
			var postfixButtons = conf.postfixButtons;
			if ( postfixButtons ) {
				if ( ! conf.buttons ) {
					conf.buttons = [];
				}

				for ( i=0, ien=postfixButtons.length ; i<ien ; i++ ) {
					conf.buttons.push( postfixButtons[i] );
				}

				conf.postfixButtons = null;
			}

			var prefixButtons = conf.prefixButtons;
			if ( prefixButtons ) {
				if ( ! conf.buttons ) {
					conf.buttons = [];
				}

				for ( i=0, ien=prefixButtons.length ; i<ien ; i++ ) {
					conf.buttons.splice( i, 0, prefixButtons[i] );
				}

				conf.prefixButtons = null;
			}

			// Although we want the `conf` object to overwrite almost all of
			// the properties of the object being extended, the `extend`
			// property should come from the object being extended
			conf.extend = objArray.extend;
		}

		return conf;
	},

	/**
	 * Display (and replace if there is an existing one) a popover attached to a button
	 * @param {string|node} content Content to show
	 * @param {DataTable.Api} hostButton DT API instance of the button
	 * @param {object} inOpts Options (see object below for all options)
	 */
	_popover: function ( content, hostButton, inOpts ) {
		var dt = hostButton;
		var buttonsSettings = this.c;
		var options = $.extend( {
			align: 'button-left', // button-right, dt-container
			autoClose: false,
			background: true,
			backgroundClassName: 'dt-button-background',
			contentClassName: buttonsSettings.dom.collection.className,
			collectionLayout: '',
			collectionTitle: '',
			dropup: false,
			fade: 400,
			rightAlignClassName: 'dt-button-right',
			tag: buttonsSettings.dom.collection.tag
		}, inOpts );
		var hostNode = hostButton.node();

		var close = function () {
			_fadeOut(
				$('.dt-button-collection'),
				options.fade,
				function () {
					$(this).detach();
				}
			);

			$(dt.buttons( '[aria-haspopup="true"][aria-expanded="true"]' ).nodes())
				.attr('aria-expanded', 'false');

			$('div.dt-button-background').off( 'click.dtb-collection' );
			Buttons.background( false, options.backgroundClassName, options.fade, hostNode );

			$('body').off( '.dtb-collection' );
			dt.off( 'buttons-action.b-internal' );
		};

		if (content === false) {
			close();
		}

		var existingExpanded = $(dt.buttons( '[aria-haspopup="true"][aria-expanded="true"]' ).nodes());
		if ( existingExpanded.length ) {
			hostNode = existingExpanded.eq(0);

			close();
		}

		var display = $('<div/>')
			.addClass('dt-button-collection')
			.addClass(options.collectionLayout)
			.css('display', 'none');

		content = $(content)
			.addClass(options.contentClassName)
			.attr('role', 'menu')
			.appendTo(display);

		hostNode.attr( 'aria-expanded', 'true' );

		if ( hostNode.parents('body')[0] !== document.body ) {
			hostNode = document.body.lastChild;
		}

		if ( options.collectionTitle ) {
			display.prepend('<div class="dt-button-collection-title">'+options.collectionTitle+'</div>');
		}

		_fadeIn( display.insertAfter( hostNode ), options.fade );

		var tableContainer = $( hostButton.table().container() );
		var position = display.css( 'position' );

		if ( options.align === 'dt-container' ) {
			hostNode = hostNode.parent();
			display.css('width', tableContainer.width());
		}

		// Align the popover relative to the DataTables container
		// Useful for wide popovers such as SearchPanes
		if (position === 'absolute') {
			// Align relative to the host button
			var hostPosition = hostNode.position();
			var buttonPosition = $(hostButton.node()).position();

			display.css( {
				top: buttonPosition.top + hostNode.outerHeight(),
				left: hostPosition.left
			} );

			// calculate overflow when positioned beneath
			var collectionHeight = display.outerHeight();
			var tableBottom = tableContainer.offset().top + tableContainer.height();
			var listBottom = buttonPosition.top + hostNode.outerHeight() + collectionHeight;
			var bottomOverflow = listBottom - tableBottom;

			// calculate overflow when positioned above
			var listTop = buttonPosition.top - collectionHeight;
			var tableTop = tableContainer.offset().top;
			var topOverflow = tableTop - listTop;

			// if bottom overflow is larger, move to the top because it fits better, or if dropup is requested
			var moveTop = buttonPosition.top - collectionHeight - 5;
			if ( (bottomOverflow > topOverflow || options.dropup) && -moveTop < tableTop ) {
				display.css( 'top', moveTop);
			}

			// Get the size of the container (left and width - and thus also right)
			var tableLeft = tableContainer.offset().left;
			var tableWidth = tableContainer.width();
			var tableRight = tableLeft + tableWidth;

			// Get the size of the popover (left and width - and ...)
			var popoverLeft = display.offset().left;
			var popoverWidth = display.width();
			var popoverRight = popoverLeft + popoverWidth;

			// Get the size of the host buttons (left and width - and ...)
			var buttonsLeft = hostNode.offset().left;
			var buttonsWidth = hostNode.outerWidth()
			var buttonsRight = buttonsLeft + buttonsWidth;

			if (
				display.hasClass( options.rightAlignClassName ) ||
				display.hasClass( options.leftAlignClassName ) ||
				options.align === 'dt-container'
			){
				// You've then got all the numbers you need to do some calculations and if statements,
				//  so we can do some quick JS maths and apply it only once
				// If it has the right align class OR the buttons are right aligned OR the button container is floated right,
				//  then calculate left position for the popover to align the popover to the right hand
				//  side of the button - check to see if the left of the popover is inside the table container.
				// If not, move the popover so it is, but not more than it means that the popover is to the right of the table container
				var popoverShuffle = 0;
				if ( display.hasClass( options.rightAlignClassName )) {
					popoverShuffle = buttonsRight - popoverRight;
					if(tableLeft > (popoverLeft + popoverShuffle)){
						var leftGap = tableLeft - (popoverLeft + popoverShuffle);
						var rightGap = tableRight - (popoverRight + popoverShuffle);
		
						if(leftGap > rightGap){
							popoverShuffle += rightGap; 
						}
						else {
							popoverShuffle += leftGap;
						}
					}
				}
				// else attempt to left align the popover to the button. Similar to above, if the popover's right goes past the table container's right,
				//  then move it back, but not so much that it goes past the left of the table container
				else {
					popoverShuffle = tableLeft - popoverLeft;
	
					if(tableRight < (popoverRight + popoverShuffle)){
						var leftGap = tableLeft - (popoverLeft + popoverShuffle);
						var rightGap = tableRight - (popoverRight + popoverShuffle);
	
						if(leftGap > rightGap ){
							popoverShuffle += rightGap;
						}
						else {
							popoverShuffle += leftGap;
						}
	
					}
				}
	
				display.css('left', display.position().left + popoverShuffle);
			}
			else {
				var top = hostNode.offset().top
				var popoverShuffle = 0;

				popoverShuffle = options.align === 'button-right'
					? buttonsRight - popoverRight
					: buttonsLeft - popoverLeft;

				display.css('left', display.position().left + popoverShuffle);
			}
			
			
		}
		else {
			// Fix position - centre on screen
			var top = display.height() / 2;
			if ( top > $(window).height() / 2 ) {
				top = $(window).height() / 2;
			}

			display.css( 'marginTop', top*-1 );
		}

		if ( options.background ) {
			Buttons.background( true, options.backgroundClassName, options.fade, hostNode );
		}

		// This is bonkers, but if we don't have a click listener on the
		// background element, iOS Safari will ignore the body click
		// listener below. An empty function here is all that is
		// required to make it work...
		$('div.dt-button-background').on( 'click.dtb-collection', function () {} );

		$('body')
			.on( 'click.dtb-collection', function (e) {
				// andSelf is deprecated in jQ1.8, but we want 1.7 compat
				var back = $.fn.addBack ? 'addBack' : 'andSelf';
				var parent = $(e.target).parent()[0];

				if (( ! $(e.target).parents()[back]().filter( content ).length  && !$(parent).hasClass('dt-buttons')) || $(e.target).hasClass('dt-button-background')) {
					close();
				}
			} )
			.on( 'keyup.dtb-collection', function (e) {
				if ( e.keyCode === 27 ) {
					close();
				}
			} );

		if ( options.autoClose ) {
			setTimeout( function () {
				dt.on( 'buttons-action.b-internal', function (e, btn, dt, node) {
					if ( node[0] === hostNode[0] ) {
						return;
					}
					close();
				} );
			}, 0);
		}

		$(display).trigger('buttons-popover.dt');
	}
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 */

/**
 * Show / hide a background layer behind a collection
 * @param  {boolean} Flag to indicate if the background should be shown or
 *   hidden 
 * @param  {string} Class to assign to the background
 * @static
 */
Buttons.background = function ( show, className, fade, insertPoint ) {
	if ( fade === undefined ) {
		fade = 400;
	}
	if ( ! insertPoint ) {
		insertPoint = document.body;
	}

	if ( show ) {
		_fadeIn(
			$('<div/>')
				.addClass( className )
				.css( 'display', 'none' )
				.insertAfter( insertPoint ),
			fade
		);
	}
	else {
		_fadeOut(
			$('div.'+className),
			fade,
			function () {
				$(this)
					.removeClass( className )
					.remove();
			}
		);
	}
};

/**
 * Instance selector - select Buttons instances based on an instance selector
 * value from the buttons assigned to a DataTable. This is only useful if
 * multiple instances are attached to a DataTable.
 * @param  {string|int|array} Instance selector - see `instance-selector`
 *   documentation on the DataTables site
 * @param  {array} Button instance array that was attached to the DataTables
 *   settings object
 * @return {array} Buttons instances
 * @static
 */
Buttons.instanceSelector = function ( group, buttons )
{
	if ( group === undefined || group === null ) {
		return $.map( buttons, function ( v ) {
			return v.inst;
		} );
	}

	var ret = [];
	var names = $.map( buttons, function ( v ) {
		return v.name;
	} );

	// Flatten the group selector into an array of single options
	var process = function ( input ) {
		if ( Array.isArray( input ) ) {
			for ( var i=0, ien=input.length ; i<ien ; i++ ) {
				process( input[i] );
			}
			return;
		}

		if ( typeof input === 'string' ) {
			if ( input.indexOf( ',' ) !== -1 ) {
				// String selector, list of names
				process( input.split(',') );
			}
			else {
				// String selector individual name
				var idx = $.inArray( input.trim(), names );

				if ( idx !== -1 ) {
					ret.push( buttons[ idx ].inst );
				}
			}
		}
		else if ( typeof input === 'number' ) {
			// Index selector
			ret.push( buttons[ input ].inst );
		}
	};
	
	process( group );

	return ret;
};

/**
 * Button selector - select one or more buttons from a selector input so some
 * operation can be performed on them.
 * @param  {array} Button instances array that the selector should operate on
 * @param  {string|int|node|jQuery|array} Button selector - see
 *   `button-selector` documentation on the DataTables site
 * @return {array} Array of objects containing `inst` and `idx` properties of
 *   the selected buttons so you know which instance each button belongs to.
 * @static
 */
Buttons.buttonSelector = function ( insts, selector )
{
	var ret = [];
	var nodeBuilder = function ( a, buttons, baseIdx ) {
		var button;
		var idx;

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			button = buttons[i];

			if ( button ) {
				idx = baseIdx !== undefined ?
					baseIdx+i :
					i+'';

				a.push( {
					node: button.node,
					name: button.conf.name,
					idx:  idx
				} );

				if ( button.buttons ) {
					nodeBuilder( a, button.buttons, idx+'-' );
				}
			}
		}
	};

	var run = function ( selector, inst ) {
		var i, ien;
		var buttons = [];
		nodeBuilder( buttons, inst.s.buttons );

		var nodes = $.map( buttons, function (v) {
			return v.node;
		} );

		if ( Array.isArray( selector ) || selector instanceof $ ) {
			for ( i=0, ien=selector.length ; i<ien ; i++ ) {
				run( selector[i], inst );
			}
			return;
		}

		if ( selector === null || selector === undefined || selector === '*' ) {
			// Select all
			for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
				ret.push( {
					inst: inst,
					node: buttons[i].node
				} );
			}
		}
		else if ( typeof selector === 'number' ) {
			// Main button index selector
			ret.push( {
				inst: inst,
				node: inst.s.buttons[ selector ].node
			} );
		}
		else if ( typeof selector === 'string' ) {
			if ( selector.indexOf( ',' ) !== -1 ) {
				// Split
				var a = selector.split(',');

				for ( i=0, ien=a.length ; i<ien ; i++ ) {
					run( a[i].trim(), inst );
				}
			}
			else if ( selector.match( /^\d+(\-\d+)*$/ ) ) {
				// Sub-button index selector
				var indexes = $.map( buttons, function (v) {
					return v.idx;
				} );

				ret.push( {
					inst: inst,
					node: buttons[ $.inArray( selector, indexes ) ].node
				} );
			}
			else if ( selector.indexOf( ':name' ) !== -1 ) {
				// Button name selector
				var name = selector.replace( ':name', '' );

				for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
					if ( buttons[i].name === name ) {
						ret.push( {
							inst: inst,
							node: buttons[i].node
						} );
					}
				}
			}
			else {
				// jQuery selector on the nodes
				$( nodes ).filter( selector ).each( function () {
					ret.push( {
						inst: inst,
						node: this
					} );
				} );
			}
		}
		else if ( typeof selector === 'object' && selector.nodeName ) {
			// Node selector
			var idx = $.inArray( selector, nodes );

			if ( idx !== -1 ) {
				ret.push( {
					inst: inst,
					node: nodes[ idx ]
				} );
			}
		}
	};


	for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
		var inst = insts[i];

		run( selector, inst );
	}

	return ret;
};

/**
 * Default function used for formatting output data.
 * @param {*} str Data to strip
 */
Buttons.stripData = function ( str, config ) {
	if ( typeof str !== 'string' ) {
		return str;
	}

	// Always remove script tags
	str = str.replace( /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '' );

	// Always remove comments
	str = str.replace( /<!\-\-.*?\-\->/g, '' );

	if ( ! config || config.stripHtml ) {
		str = str.replace( /<[^>]*>/g, '' );
	}

	if ( ! config || config.trim ) {
		str = str.replace( /^\s+|\s+$/g, '' );
	}

	if ( ! config || config.stripNewlines ) {
		str = str.replace( /\n/g, ' ' );
	}

	if ( ! config || config.decodeEntities ) {
		_exportTextarea.innerHTML = str;
		str = _exportTextarea.value;
	}

	return str;
};


/**
 * Buttons defaults. For full documentation, please refer to the docs/option
 * directory or the DataTables site.
 * @type {Object}
 * @static
 */
Buttons.defaults = {
	buttons: [ 'copy', 'excel', 'csv', 'pdf', 'print' ],
	name: 'main',
	tabIndex: 0,
	dom: {
		container: {
			tag: 'div',
			className: 'dt-buttons'
		},
		collection: {
			tag: 'div',
			className: ''
		},
		button: {
			tag: 'button',
			className: 'dt-button',
			active: 'active',
			disabled: 'disabled'
		},
		buttonLiner: {
			tag: 'span',
			className: ''
		}
	}
};

/**
 * Version information
 * @type {string}
 * @static
 */
Buttons.version = '1.7.1';


$.extend( _dtButtons, {
	collection: {
		text: function ( dt ) {
			return dt.i18n( 'buttons.collection', 'Collection' );
		},
		className: 'buttons-collection',
		init: function ( dt, button, config ) {
			button.attr( 'aria-expanded', false );
		},
		action: function ( e, dt, button, config ) {
			e.stopPropagation();

			if ( config._collection.parents('body').length ) {
				this.popover(false, config);
			}
			else {
				this.popover(config._collection, config);
			}
		},
		attr: {
			'aria-haspopup': true
		}
		// Also the popover options, defined in Buttons.popover
	},
	copy: function ( dt, conf ) {
		if ( _dtButtons.copyHtml5 ) {
			return 'copyHtml5';
		}
	},
	csv: function ( dt, conf ) {
		if ( _dtButtons.csvHtml5 && _dtButtons.csvHtml5.available( dt, conf ) ) {
			return 'csvHtml5';
		}
	},
	excel: function ( dt, conf ) {
		if ( _dtButtons.excelHtml5 && _dtButtons.excelHtml5.available( dt, conf ) ) {
			return 'excelHtml5';
		}
	},
	pdf: function ( dt, conf ) {
		if ( _dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available( dt, conf ) ) {
			return 'pdfHtml5';
		}
	},
	pageLength: function ( dt ) {
		var lengthMenu = dt.settings()[0].aLengthMenu;
		var vals = [];
		var lang = [];
		var text = function ( dt ) {
			return dt.i18n( 'buttons.pageLength', {
				"-1": 'Show all rows',
				_:    'Show %d rows'
			}, dt.page.len() );
		};

		// Support for DataTables 1.x 2D array
		if (Array.isArray( lengthMenu[0] )) {
			vals = lengthMenu[0];
			lang = lengthMenu[1];
		}
		else {
			for (var i=0 ; i<lengthMenu.length ; i++) {
				var option = lengthMenu[i];

				// Support for DataTables 2 object in the array
				if ($.isPlainObject(option)) {
					vals.push(option.value);
					lang.push(option.label);
				}
				else {
					vals.push(option);
					lang.push(option);
				}
			}
		}

		return {
			extend: 'collection',
			text: text,
			className: 'buttons-page-length',
			autoClose: true,
			buttons: $.map( vals, function ( val, i ) {
				return {
					text: lang[i],
					className: 'button-page-length',
					action: function ( e, dt ) {
						dt.page.len( val ).draw();
					},
					init: function ( dt, node, conf ) {
						var that = this;
						var fn = function () {
							that.active( dt.page.len() === val );
						};

						dt.on( 'length.dt'+conf.namespace, fn );
						fn();
					},
					destroy: function ( dt, node, conf ) {
						dt.off( 'length.dt'+conf.namespace );
					}
				};
			} ),
			init: function ( dt, node, conf ) {
				var that = this;
				dt.on( 'length.dt'+conf.namespace, function () {
					that.text( conf.text );
				} );
			},
			destroy: function ( dt, node, conf ) {
				dt.off( 'length.dt'+conf.namespace );
			}
		};
	}
} );


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API
 *
 * For complete documentation, please refer to the docs/api directory or the
 * DataTables site
 */

// Buttons group and individual button selector
DataTable.Api.register( 'buttons()', function ( group, selector ) {
	// Argument shifting
	if ( selector === undefined ) {
		selector = group;
		group = undefined;
	}

	this.selector.buttonGroup = group;

	var res = this.iterator( true, 'table', function ( ctx ) {
		if ( ctx._buttons ) {
			return Buttons.buttonSelector(
				Buttons.instanceSelector( group, ctx._buttons ),
				selector
			);
		}
	}, true );

	res._groupSelector = group;
	return res;
} );

// Individual button selector
DataTable.Api.register( 'button()', function ( group, selector ) {
	// just run buttons() and truncate
	var buttons = this.buttons( group, selector );

	if ( buttons.length > 1 ) {
		buttons.splice( 1, buttons.length );
	}

	return buttons;
} );

// Active buttons
DataTable.Api.registerPlural( 'buttons().active()', 'button().active()', function ( flag ) {
	if ( flag === undefined ) {
		return this.map( function ( set ) {
			return set.inst.active( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.active( set.node, flag );
	} );
} );

// Get / set button action
DataTable.Api.registerPlural( 'buttons().action()', 'button().action()', function ( action ) {
	if ( action === undefined ) {
		return this.map( function ( set ) {
			return set.inst.action( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.action( set.node, action );
	} );
} );

// Enable / disable buttons
DataTable.Api.register( ['buttons().enable()', 'button().enable()'], function ( flag ) {
	return this.each( function ( set ) {
		set.inst.enable( set.node, flag );
	} );
} );

// Disable buttons
DataTable.Api.register( ['buttons().disable()', 'button().disable()'], function () {
	return this.each( function ( set ) {
		set.inst.disable( set.node );
	} );
} );

// Get button nodes
DataTable.Api.registerPlural( 'buttons().nodes()', 'button().node()', function () {
	var jq = $();

	// jQuery will automatically reduce duplicates to a single entry
	$( this.each( function ( set ) {
		jq = jq.add( set.inst.node( set.node ) );
	} ) );

	return jq;
} );

// Get / set button processing state
DataTable.Api.registerPlural( 'buttons().processing()', 'button().processing()', function ( flag ) {
	if ( flag === undefined ) {
		return this.map( function ( set ) {
			return set.inst.processing( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.processing( set.node, flag );
	} );
} );

// Get / set button text (i.e. the button labels)
DataTable.Api.registerPlural( 'buttons().text()', 'button().text()', function ( label ) {
	if ( label === undefined ) {
		return this.map( function ( set ) {
			return set.inst.text( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.text( set.node, label );
	} );
} );

// Trigger a button's action
DataTable.Api.registerPlural( 'buttons().trigger()', 'button().trigger()', function () {
	return this.each( function ( set ) {
		set.inst.node( set.node ).trigger( 'click' );
	} );
} );

// Button resolver to the popover
DataTable.Api.register( 'button().popover()', function (content, options) {
	return this.map( function ( set ) {
		return set.inst._popover( content, this.button(this[0].node), options );
	} );
} );

// Get the container elements
DataTable.Api.register( 'buttons().containers()', function () {
	var jq = $();
	var groupSelector = this._groupSelector;

	// We need to use the group selector directly, since if there are no buttons
	// the result set will be empty
	this.iterator( true, 'table', function ( ctx ) {
		if ( ctx._buttons ) {
			var insts = Buttons.instanceSelector( groupSelector, ctx._buttons );

			for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
				jq = jq.add( insts[i].container() );
			}
		}
	} );

	return jq;
} );

DataTable.Api.register( 'buttons().container()', function () {
	// API level of nesting is `buttons()` so we can zip into the containers method
	return this.containers().eq(0);
} );

// Add a new button
DataTable.Api.register( 'button().add()', function ( idx, conf ) {
	var ctx = this.context;

	// Don't use `this` as it could be empty - select the instances directly
	if ( ctx.length ) {
		var inst = Buttons.instanceSelector( this._groupSelector, ctx[0]._buttons );

		if ( inst.length ) {
			inst[0].add( conf, idx );
		}
	}

	return this.button( this._groupSelector, idx );
} );

// Destroy the button sets selected
DataTable.Api.register( 'buttons().destroy()', function () {
	this.pluck( 'inst' ).unique().each( function ( inst ) {
		inst.destroy();
	} );

	return this;
} );

// Remove a button
DataTable.Api.registerPlural( 'buttons().remove()', 'buttons().remove()', function () {
	this.each( function ( set ) {
		set.inst.remove( set.node );
	} );

	return this;
} );

// Information box that can be used by buttons
var _infoTimer;
DataTable.Api.register( 'buttons.info()', function ( title, message, time ) {
	var that = this;

	if ( title === false ) {
		this.off('destroy.btn-info');
		_fadeOut(
			$('#datatables_buttons_info'),
			400,
			function () {
				$(this).remove();
			}
		);
		clearTimeout( _infoTimer );
		_infoTimer = null;

		return this;
	}

	if ( _infoTimer ) {
		clearTimeout( _infoTimer );
	}

	if ( $('#datatables_buttons_info').length ) {
		$('#datatables_buttons_info').remove();
	}

	title = title ? '<h2>'+title+'</h2>' : '';

	_fadeIn(
		$('<div id="datatables_buttons_info" class="dt-button-info"/>')
			.html( title )
			.append( $('<div/>')[ typeof message === 'string' ? 'html' : 'append' ]( message ) )
			.css( 'display', 'none' )
			.appendTo( 'body' )
	);

	if ( time !== undefined && time !== 0 ) {
		_infoTimer = setTimeout( function () {
			that.buttons.info( false );
		}, time );
	}

	this.on('destroy.btn-info', function () {
		that.buttons.info(false);
	});

	return this;
} );

// Get data from the table for export - this is common to a number of plug-in
// buttons so it is included in the Buttons core library
DataTable.Api.register( 'buttons.exportData()', function ( options ) {
	if ( this.context.length ) {
		return _exportData( new DataTable.Api( this.context[0] ), options );
	}
} );

// Get information about the export that is common to many of the export data
// types (DRY)
DataTable.Api.register( 'buttons.exportInfo()', function ( conf ) {
	if ( ! conf ) {
		conf = {};
	}

	return {
		filename: _filename( conf ),
		title: _title( conf ),
		messageTop: _message(this, conf.message || conf.messageTop, 'top'),
		messageBottom: _message(this, conf.messageBottom, 'bottom')
	};
} );



/**
 * Get the file name for an exported file.
 *
 * @param {object}	config Button configuration
 * @param {boolean} incExtension Include the file name extension
 */
var _filename = function ( config )
{
	// Backwards compatibility
	var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined && config.title !== null && config.title !== '' ?
		config.title :
		config.filename;

	if ( typeof filename === 'function' ) {
		filename = filename();
	}

	if ( filename === undefined || filename === null ) {
		return null;
	}

	if ( filename.indexOf( '*' ) !== -1 ) {
		filename = filename.replace( '*', $('head > title').text() ).trim();
	}

	// Strip characters which the OS will object to
	filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");

	var extension = _stringOrFunction( config.extension );
	if ( ! extension ) {
		extension = '';
	}

	return filename + extension;
};

/**
 * Simply utility method to allow parameters to be given as a function
 *
 * @param {undefined|string|function} option Option
 * @return {null|string} Resolved value
 */
var _stringOrFunction = function ( option )
{
	if ( option === null || option === undefined ) {
		return null;
	}
	else if ( typeof option === 'function' ) {
		return option();
	}
	return option;
};

/**
 * Get the title for an exported file.
 *
 * @param {object} config	Button configuration
 */
var _title = function ( config )
{
	var title = _stringOrFunction( config.title );

	return title === null ?
		null : title.indexOf( '*' ) !== -1 ?
			title.replace( '*', $('head > title').text() || 'Exported data' ) :
			title;
};

var _message = function ( dt, option, position )
{
	var message = _stringOrFunction( option );
	if ( message === null ) {
		return null;
	}

	var caption = $('caption', dt.table().container()).eq(0);
	if ( message === '*' ) {
		var side = caption.css( 'caption-side' );
		if ( side !== position ) {
			return null;
		}

		return caption.length ?
			caption.text() :
			'';
	}

	return message;
};




var _exportTextarea = $('<textarea/>')[0];
var _exportData = function ( dt, inOpts )
{
	var config = $.extend( true, {}, {
		rows:           null,
		columns:        '',
		modifier:       {
			search: 'applied',
			order:  'applied'
		},
		orthogonal:     'display',
		stripHtml:      true,
		stripNewlines:  true,
		decodeEntities: true,
		trim:           true,
		format:         {
			header: function ( d ) {
				return Buttons.stripData( d, config );
			},
			footer: function ( d ) {
				return Buttons.stripData( d, config );
			},
			body: function ( d ) {
				return Buttons.stripData( d, config );
			}
		},
		customizeData: null
	}, inOpts );

	var header = dt.columns( config.columns ).indexes().map( function (idx) {
		var el = dt.column( idx ).header();
		return config.format.header( el.innerHTML, idx, el );
	} ).toArray();

	var footer = dt.table().footer() ?
		dt.columns( config.columns ).indexes().map( function (idx) {
			var el = dt.column( idx ).footer();
			return config.format.footer( el ? el.innerHTML : '', idx, el );
		} ).toArray() :
		null;
	
	// If Select is available on this table, and any rows are selected, limit the export
	// to the selected rows. If no rows are selected, all rows will be exported. Specify
	// a `selected` modifier to control directly.
	var modifier = $.extend( {}, config.modifier );
	if ( dt.select && typeof dt.select.info === 'function' && modifier.selected === undefined ) {
		if ( dt.rows( config.rows, $.extend( { selected: true }, modifier ) ).any() ) {
			$.extend( modifier, { selected: true } )
		}
	}

	var rowIndexes = dt.rows( config.rows, modifier ).indexes().toArray();
	var selectedCells = dt.cells( rowIndexes, config.columns );
	var cells = selectedCells
		.render( config.orthogonal )
		.toArray();
	var cellNodes = selectedCells
		.nodes()
		.toArray();

	var columns = header.length;
	var rows = columns > 0 ? cells.length / columns : 0;
	var body = [];
	var cellCounter = 0;

	for ( var i=0, ien=rows ; i<ien ; i++ ) {
		var row = [ columns ];

		for ( var j=0 ; j<columns ; j++ ) {
			row[j] = config.format.body( cells[ cellCounter ], i, j, cellNodes[ cellCounter ] );
			cellCounter++;
		}

		body[i] = row;
	}

	var data = {
		header: header,
		footer: footer,
		body:   body
	};

	if ( config.customizeData ) {
		config.customizeData( data );
	}

	return data;
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interface
 */

// Attach to DataTables objects for global access
$.fn.dataTable.Buttons = Buttons;
$.fn.DataTable.Buttons = Buttons;



// DataTables creation - check if the buttons have been defined for this table,
// they will have been if the `B` option was used in `dom`, otherwise we should
// create the buttons instance here so they can be inserted into the document
// using the API. Listen for `init` for compatibility with pre 1.10.10, but to
// be removed in future.
$(document).on( 'init.dt plugin-init.dt', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var opts = settings.oInit.buttons || DataTable.defaults.buttons;

	if ( opts && ! settings._buttons ) {
		new Buttons( settings, opts ).container();
	}
} );

function _init ( settings, options ) {
	var api = new DataTable.Api( settings );
	var opts = options
		? options
		: api.init().buttons || DataTable.defaults.buttons;

	return new Buttons( api, opts ).container();
}

// DataTables `dom` feature option
DataTable.ext.feature.push( {
	fnInit: _init,
	cFeature: "B"
} );

// DataTables 2 layout feature
if ( DataTable.ext.features ) {
	DataTable.ext.features.register( 'buttons', _init );
}


return Buttons;
}));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvdmVuZG9ycy1ub2RlX21vZHVsZXNfZGF0YXRhYmxlc19uZXQtYnV0dG9uc19qc19kYXRhVGFibGVzX2J1dHRvbnNfanMuZDMwY2M1YWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsbUdBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU07QUFBQSxFQWlCSjtBQUNGLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxZQUFZO0FBQ3hCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLDhCQUE4QjtBQUMxQztBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBLG1DQUFtQyxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1idXR0b25zL2pzL2RhdGFUYWJsZXMuYnV0dG9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQnV0dG9ucyBmb3IgRGF0YVRhYmxlcyAxLjcuMVxuICogwqkyMDE2LTIwMjEgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vLyBVc2VkIGZvciBuYW1lc3BhY2luZyBldmVudHMgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGJ5IGVhY2ggaW5zdGFuY2UsIHNvIHRoZXlcbi8vIGNhbiBiZSByZW1vdmVkIG9uIGRlc3Ryb3lcbnZhciBfaW5zdENvdW50ZXIgPSAwO1xuXG4vLyBCdXR0b24gbmFtZXNwYWNpbmcgY291bnRlciBmb3IgbmFtZXNwYWNpbmcgZXZlbnRzIG9uIGluZGl2aWR1YWwgYnV0dG9uc1xudmFyIF9idXR0b25Db3VudGVyID0gMDtcblxudmFyIF9kdEJ1dHRvbnMgPSBEYXRhVGFibGUuZXh0LmJ1dHRvbnM7XG5cbi8vIEFsbG93IGZvciBqUXVlcnkgc2xpbVxuZnVuY3Rpb24gX2ZhZGVJbihlbCwgZHVyYXRpb24sIGZuKSB7XG5cdGlmICgkLmZuLmFuaW1hdGUpIHtcblx0XHRlbFxuXHRcdFx0LnN0b3AoKVxuXHRcdFx0LmZhZGVJbiggZHVyYXRpb24sIGZuICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZWwuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cblx0XHRpZiAoZm4pIHtcblx0XHRcdGZuLmNhbGwoZWwpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBfZmFkZU91dChlbCwgZHVyYXRpb24sIGZuKSB7XG5cdGlmICgkLmZuLmFuaW1hdGUpIHtcblx0XHRlbFxuXHRcdFx0LnN0b3AoKVxuXHRcdFx0LmZhZGVPdXQoIGR1cmF0aW9uLCBmbiApO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGVsLmNzcygnZGlzcGxheScsICdub25lJyk7XG5cdFx0XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHRmbi5jYWxsKGVsKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBbQnV0dG9ucyBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7W3R5cGVdfVxuICogQHBhcmFtIHtbdHlwZV19XG4gKi9cbnZhciBCdXR0b25zID0gZnVuY3Rpb24oIGR0LCBjb25maWcgKVxue1xuXHQvLyBJZiBub3QgY3JlYXRlZCB3aXRoIGEgYG5ld2Aga2V5d29yZCB0aGVuIHdlIHJldHVybiBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdFxuXHQvLyB3aWxsIHRha2UgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBEVC4gVGhpcyBhbGxvd3MgZWFzeSB1c2Ugb2YgbmV3IGluc3RhbmNlc1xuXHQvLyB3aXRoIHRoZSBgbGF5b3V0YCBvcHRpb24gLSBlLmcuIGB0b3BMZWZ0OiAkLmZuLmRhdGFUYWJsZS5CdXR0b25zKCAuLi4gKWAuXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgQnV0dG9ucykgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuXHRcdFx0cmV0dXJuIG5ldyBCdXR0b25zKCBzZXR0aW5ncywgZHQgKS5jb250YWluZXIoKTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gSWYgdGhlcmUgaXMgbm8gY29uZmlnIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3Rcblx0aWYgKCB0eXBlb2YoIGNvbmZpZyApID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRjb25maWcgPSB7fTtcdFxuXHR9XG5cdFxuXHQvLyBBbGxvdyBhIGJvb2xlYW4gdHJ1ZSBmb3IgZGVmYXVsdHNcblx0aWYgKCBjb25maWcgPT09IHRydWUgKSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXHQvLyBGb3IgZWFzeSBjb25maWd1cmF0aW9uIG9mIGJ1dHRvbnMgYW4gYXJyYXkgY2FuIGJlIGdpdmVuXG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnICkgKSB7XG5cdFx0Y29uZmlnID0geyBidXR0b25zOiBjb25maWcgfTtcblx0fVxuXG5cdHRoaXMuYyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgQnV0dG9ucy5kZWZhdWx0cywgY29uZmlnICk7XG5cblx0Ly8gRG9uJ3Qgd2FudCBhIGRlZXAgY29weSBmb3IgdGhlIGJ1dHRvbnNcblx0aWYgKCBjb25maWcuYnV0dG9ucyApIHtcblx0XHR0aGlzLmMuYnV0dG9ucyA9IGNvbmZpZy5idXR0b25zO1xuXHR9XG5cblx0dGhpcy5zID0ge1xuXHRcdGR0OiBuZXcgRGF0YVRhYmxlLkFwaSggZHQgKSxcblx0XHRidXR0b25zOiBbXSxcblx0XHRsaXN0ZW5LZXlzOiAnJyxcblx0XHRuYW1lc3BhY2U6ICdkdGInKyhfaW5zdENvdW50ZXIrKylcblx0fTtcblxuXHR0aGlzLmRvbSA9IHtcblx0XHRjb250YWluZXI6ICQoJzwnK3RoaXMuYy5kb20uY29udGFpbmVyLnRhZysnLz4nKVxuXHRcdFx0LmFkZENsYXNzKCB0aGlzLmMuZG9tLmNvbnRhaW5lci5jbGFzc05hbWUgKVxuXHR9O1xuXG5cdHRoaXMuX2NvbnN0cnVjdG9yKCk7XG59O1xuXG5cbiQuZXh0ZW5kKCBCdXR0b25zLnByb3RvdHlwZSwge1xuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIFB1YmxpYyBtZXRob2RzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGFjdGlvbiBvZiBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtpbnR8c3RyaW5nfSBCdXR0b24gaW5kZXhcblx0ICogQHJldHVybiB7ZnVuY3Rpb259XG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGFjdGlvbiBvZiBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBlbGVtZW50XG5cdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBhY3Rpb24gRnVuY3Rpb24gdG8gc2V0XG5cdCAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXG5cdCAqL1xuXHRhY3Rpb246IGZ1bmN0aW9uICggbm9kZSwgYWN0aW9uIClcblx0e1xuXHRcdHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24oIG5vZGUgKTtcblxuXHRcdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gYnV0dG9uLmNvbmYuYWN0aW9uO1xuXHRcdH1cblxuXHRcdGJ1dHRvbi5jb25mLmFjdGlvbiA9IGFjdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYW4gYWN0aXZlIGNsYXNzIHRvIHRoZSBidXR0b24gdG8gbWFrZSB0byBsb29rIGFjdGl2ZSBvciBnZXQgY3VycmVudFxuXHQgKiBhY3RpdmUgc3RhdGUuXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgQnV0dG9uIGVsZW1lbnRcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gW2ZsYWddIEVuYWJsZSAvIGRpc2FibGUgZmxhZ1xuXHQgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZyBvciBib29sZWFuIGZvciBnZXR0ZXJcblx0ICovXG5cdGFjdGl2ZTogZnVuY3Rpb24gKCBub2RlLCBmbGFnICkge1xuXHRcdHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24oIG5vZGUgKTtcblx0XHR2YXIga2xhc3MgPSB0aGlzLmMuZG9tLmJ1dHRvbi5hY3RpdmU7XG5cdFx0dmFyIGpxTm9kZSA9ICQoYnV0dG9uLm5vZGUpO1xuXG5cdFx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFOb2RlLmhhc0NsYXNzKCBrbGFzcyApO1xuXHRcdH1cblxuXHRcdGpxTm9kZS50b2dnbGVDbGFzcygga2xhc3MsIGZsYWcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmbGFnICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogQWRkIGEgbmV3IGJ1dHRvblxuXHQgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIEJ1dHRvbiBjb25maWd1cmF0aW9uIG9iamVjdCwgYmFzZSBzdHJpbmcgbmFtZSBvciBmdW5jdGlvblxuXHQgKiBAcGFyYW0ge2ludHxzdHJpbmd9IFtpZHhdIEJ1dHRvbiBpbmRleCBmb3Igd2hlcmUgdG8gaW5zZXJ0IHRoZSBidXR0b25cblx0ICogQHJldHVybiB7QnV0dG9uc30gU2VsZiBmb3IgY2hhaW5pbmdcblx0ICovXG5cdGFkZDogZnVuY3Rpb24gKCBjb25maWcsIGlkeCApXG5cdHtcblx0XHR2YXIgYnV0dG9ucyA9IHRoaXMucy5idXR0b25zO1xuXG5cdFx0aWYgKCB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdHZhciBzcGxpdCA9IGlkeC5zcGxpdCgnLScpO1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLnM7XG5cblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zcGxpdC5sZW5ndGgtMSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRiYXNlID0gYmFzZS5idXR0b25zWyBzcGxpdFtpXSoxIF07XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbnMgPSBiYXNlLmJ1dHRvbnM7XG5cdFx0XHRpZHggPSBzcGxpdFsgc3BsaXQubGVuZ3RoLTEgXSoxO1xuXHRcdH1cblxuXHRcdHRoaXMuX2V4cGFuZEJ1dHRvbiggYnV0dG9ucywgY29uZmlnLCBiYXNlICE9PSB1bmRlZmluZWQsIGlkeCApO1xuXHRcdHRoaXMuX2RyYXcoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNvbnRhaW5lciBub2RlIGZvciB0aGUgYnV0dG9uc1xuXHQgKiBAcmV0dXJuIHtqUXVlcnl9IEJ1dHRvbnMgbm9kZVxuXHQgKi9cblx0Y29udGFpbmVyOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcblx0fSxcblxuXHQvKipcblx0ICogRGlzYWJsZSBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBub2RlXG5cdCAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXG5cdCAqL1xuXHRkaXNhYmxlOiBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSApO1xuXG5cdFx0JChidXR0b24ubm9kZSlcblx0XHRcdC5hZGRDbGFzcyggdGhpcy5jLmRvbS5idXR0b24uZGlzYWJsZWQgKVxuXHRcdFx0LmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogRGVzdHJveSB0aGUgaW5zdGFuY2UsIGNsZWFuaW5nIHVwIGV2ZW50IGhhbmRsZXJzIGFuZCByZW1vdmluZyBET01cblx0ICogZWxlbWVudHNcblx0ICogQHJldHVybiB7QnV0dG9uc30gU2VsZiBmb3IgY2hhaW5pbmdcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHQvLyBLZXkgZXZlbnQgbGlzdGVuZXJcblx0XHQkKCdib2R5Jykub2ZmKCAna2V5dXAuJyt0aGlzLnMubmFtZXNwYWNlICk7XG5cblx0XHQvLyBJbmRpdmlkdWFsIGJ1dHRvbiBkZXN0cm95IChzbyB0aGV5IGNhbiByZW1vdmUgdGhlaXIgb3duIGV2ZW50cyBpZlxuXHRcdC8vIG5lZWRlZCkuIFRha2UgYSBjb3B5IGFzIHRoZSBhcnJheSBpcyBtb2RpZmllZCBieSBgcmVtb3ZlYFxuXHRcdHZhciBidXR0b25zID0gdGhpcy5zLmJ1dHRvbnMuc2xpY2UoKTtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdFxuXHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR0aGlzLnJlbW92ZSggYnV0dG9uc1tpXS5ub2RlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGFpbmVyXG5cdFx0dGhpcy5kb20uY29udGFpbmVyLnJlbW92ZSgpO1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gdGhlIHNldHRpbmdzIG9iamVjdCBjb2xsZWN0aW9uXG5cdFx0dmFyIGJ1dHRvbkluc3RzID0gdGhpcy5zLmR0LnNldHRpbmdzKClbMF07XG5cblx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25JbnN0cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYnV0dG9uSW5zdHMuaW5zdCA9PT0gdGhpcyApIHtcblx0XHRcdFx0YnV0dG9uSW5zdHMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFbmFibGUgLyBkaXNhYmxlIGEgYnV0dG9uXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgQnV0dG9uIG5vZGVcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV0gRW5hYmxlIC8gZGlzYWJsZSBmbGFnXG5cdCAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXG5cdCAqL1xuXHRlbmFibGU6IGZ1bmN0aW9uICggbm9kZSwgZmxhZyApXG5cdHtcblx0XHRpZiAoIGZsYWcgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzYWJsZSggbm9kZSApO1xuXHRcdH1cblxuXHRcdHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24oIG5vZGUgKTtcblx0XHQkKGJ1dHRvbi5ub2RlKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLmMuZG9tLmJ1dHRvbi5kaXNhYmxlZCApXG5cdFx0XHQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGluc3RhbmNlIG5hbWUgZm9yIHRoZSBidXR0b24gc2V0IHNlbGVjdG9yXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gSW5zdGFuY2UgbmFtZVxuXHQgKi9cblx0bmFtZTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmMubmFtZTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGEgYnV0dG9uJ3Mgbm9kZSBvZiB0aGUgYnV0dG9ucyBjb250YWluZXIgaWYgbm8gYnV0dG9uIGlzIGdpdmVuXG5cdCAqIEBwYXJhbSAge25vZGV9IFtub2RlXSBCdXR0b24gbm9kZVxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9IEJ1dHRvbiBlbGVtZW50LCBvciBjb250YWluZXJcblx0ICovXG5cdG5vZGU6IGZ1bmN0aW9uICggbm9kZSApXG5cdHtcblx0XHRpZiAoICEgbm9kZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbS5jb250YWluZXI7XG5cdFx0fVxuXG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSApO1xuXHRcdHJldHVybiAkKGJ1dHRvbi5ub2RlKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IC8gZ2V0IGEgcHJvY2Vzc2luZyBjbGFzcyBvbiB0aGUgc2VsZWN0ZWQgYnV0dG9uXG5cdCAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZSBUcmlnZ2VyaW5nIGJ1dHRvbiBub2RlXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW59IGZsYWcgdHJ1ZSB0byBhZGQsIGZhbHNlIHRvIHJlbW92ZSwgdW5kZWZpbmVkIHRvIGdldFxuXHQgKiBAcmV0dXJuIHtib29sZWFufEJ1dHRvbnN9IEdldHRlciB2YWx1ZSBvciB0aGlzIGlmIGEgc2V0dGVyLlxuXHQgKi9cblx0cHJvY2Vzc2luZzogZnVuY3Rpb24gKCBub2RlLCBmbGFnIClcblx0e1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKCBub2RlICk7XG5cblx0XHRpZiAoIGZsYWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiAkKGJ1dHRvbi5ub2RlKS5oYXNDbGFzcyggJ3Byb2Nlc3NpbmcnICk7XG5cdFx0fVxuXG5cdFx0JChidXR0b24ubm9kZSkudG9nZ2xlQ2xhc3MoICdwcm9jZXNzaW5nJywgZmxhZyApO1xuXG5cdFx0JChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlckhhbmRsZXIoICdidXR0b25zLXByb2Nlc3NpbmcuZHQnLCBbXG5cdFx0XHRmbGFnLCBkdC5idXR0b24oIG5vZGUgKSwgZHQsICQobm9kZSksIGJ1dHRvbi5jb25mXG5cdFx0XSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGJ1dHRvbi5cblx0ICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxuXHQgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZ1xuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIG5vZGUgKVxuXHR7XG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSApO1xuXHRcdHZhciBob3N0ID0gdGhpcy5fbm9kZVRvSG9zdCggbm9kZSApO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblxuXHRcdC8vIFJlbW92ZSBhbnkgY2hpbGQgYnV0dG9ucyBmaXJzdFxuXHRcdGlmICggYnV0dG9uLmJ1dHRvbnMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggdmFyIGk9YnV0dG9uLmJ1dHRvbnMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tICkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZSggYnV0dG9uLmJ1dHRvbnNbaV0ubm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFsbG93IHRoZSBidXR0b24gdG8gcmVtb3ZlIGV2ZW50IGhhbmRsZXJzLCBldGNcblx0XHRpZiAoIGJ1dHRvbi5jb25mLmRlc3Ryb3kgKSB7XG5cdFx0XHRidXR0b24uY29uZi5kZXN0cm95LmNhbGwoIGR0LmJ1dHRvbihub2RlKSwgZHQsICQobm9kZSksIGJ1dHRvbi5jb25mICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVtb3ZlS2V5KCBidXR0b24uY29uZiApO1xuXG5cdFx0JChidXR0b24ubm9kZSkucmVtb3ZlKCk7XG5cblx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCBidXR0b24sIGhvc3QgKTtcblx0XHRob3N0LnNwbGljZSggaWR4LCAxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSB0ZXh0IGZvciBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtpbnR8c3RyaW5nfSBub2RlIEJ1dHRvbiBpbmRleFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IEJ1dHRvbiB0ZXh0XG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIHRleHQgZm9yIGEgYnV0dG9uXG5cdCAqIEBwYXJhbSAge2ludHxzdHJpbmd8ZnVuY3Rpb259IG5vZGUgQnV0dG9uIGluZGV4XG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbGFiZWwgVGV4dFxuXHQgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZ1xuXHQgKi9cblx0dGV4dDogZnVuY3Rpb24gKCBub2RlLCBsYWJlbCApXG5cdHtcblx0XHR2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKCBub2RlICk7XG5cdFx0dmFyIGJ1dHRvbkxpbmVyID0gdGhpcy5jLmRvbS5jb2xsZWN0aW9uLmJ1dHRvbkxpbmVyO1xuXHRcdHZhciBsaW5lclRhZyA9IGJ1dHRvbi5pbkNvbGxlY3Rpb24gJiYgYnV0dG9uTGluZXIgJiYgYnV0dG9uTGluZXIudGFnID9cblx0XHRcdGJ1dHRvbkxpbmVyLnRhZyA6XG5cdFx0XHR0aGlzLmMuZG9tLmJ1dHRvbkxpbmVyLnRhZztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGpxTm9kZSA9ICQoYnV0dG9uLm5vZGUpO1xuXHRcdHZhciB0ZXh0ID0gZnVuY3Rpb24gKCBvcHQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdG9wdCggZHQsIGpxTm9kZSwgYnV0dG9uLmNvbmYgKSA6XG5cdFx0XHRcdG9wdDtcblx0XHR9O1xuXG5cdFx0aWYgKCBsYWJlbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRleHQoIGJ1dHRvbi5jb25mLnRleHQgKTtcblx0XHR9XG5cblx0XHRidXR0b24uY29uZi50ZXh0ID0gbGFiZWw7XG5cblx0XHRpZiAoIGxpbmVyVGFnICkge1xuXHRcdFx0anFOb2RlLmNoaWxkcmVuKCBsaW5lclRhZyApLmh0bWwoIHRleHQobGFiZWwpICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0anFOb2RlLmh0bWwoIHRleHQobGFiZWwpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIENvbnN0cnVjdG9yXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBCdXR0b25zIGNvbnN0cnVjdG9yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBkdFNldHRpbmdzID0gZHQuc2V0dGluZ3MoKVswXTtcblx0XHR2YXIgYnV0dG9ucyA9ICB0aGlzLmMuYnV0dG9ucztcblxuXHRcdGlmICggISBkdFNldHRpbmdzLl9idXR0b25zICkge1xuXHRcdFx0ZHRTZXR0aW5ncy5fYnV0dG9ucyA9IFtdO1xuXHRcdH1cblxuXHRcdGR0U2V0dGluZ3MuX2J1dHRvbnMucHVzaCgge1xuXHRcdFx0aW5zdDogdGhpcyxcblx0XHRcdG5hbWU6IHRoaXMuYy5uYW1lXG5cdFx0fSApO1xuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR0aGlzLmFkZCggYnV0dG9uc1tpXSApO1xuXHRcdH1cblxuXHRcdGR0Lm9uKCAnZGVzdHJveScsIGZ1bmN0aW9uICggZSwgc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzID09PSBkdFNldHRpbmdzICkge1xuXHRcdFx0XHR0aGF0LmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBHbG9iYWwga2V5IGV2ZW50IGJpbmRpbmcgdG8gbGlzdGVuIGZvciBidXR0b24ga2V5c1xuXHRcdCQoJ2JvZHknKS5vbiggJ2tleXVwLicrdGhpcy5zLm5hbWVzcGFjZSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0aWYgKCAhIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdFx0Ly8gU1VzZSBhIHN0cmluZyBvZiBjaGFyYWN0ZXJzIGZvciBmYXN0IGxvb2t1cCBvZiBpZiB3ZSBuZWVkIHRvXG5cdFx0XHRcdC8vIGhhbmRsZSB0aGlzXG5cdFx0XHRcdHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAoIHRoYXQucy5saXN0ZW5LZXlzLnRvTG93ZXJDYXNlKCkuaW5kZXhPZiggY2hhcmFjdGVyICkgIT09IC0xICkge1xuXHRcdFx0XHRcdHRoYXQuX2tleXByZXNzKCBjaGFyYWN0ZXIsIGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogUHJpdmF0ZSBtZXRob2RzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBuZXcgYnV0dG9uIHRvIHRoZSBrZXkgcHJlc3MgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtvYmplY3R9IGNvbmYgUmVzb2x2ZWQgYnV0dG9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYWRkS2V5OiBmdW5jdGlvbiAoIGNvbmYgKVxuXHR7XG5cdFx0aWYgKCBjb25mLmtleSApIHtcblx0XHRcdHRoaXMucy5saXN0ZW5LZXlzICs9ICQuaXNQbGFpbk9iamVjdCggY29uZi5rZXkgKSA/XG5cdFx0XHRcdGNvbmYua2V5LmtleSA6XG5cdFx0XHRcdGNvbmYua2V5O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSW5zZXJ0IHRoZSBidXR0b25zIGludG8gdGhlIGNvbnRhaW5lci4gQ2FsbCB3aXRob3V0IHBhcmFtZXRlcnMhXG5cdCAqIEBwYXJhbSAge25vZGV9IFtjb250YWluZXJdIFJlY3Vyc2l2ZSBvbmx5IC0gSW5zZXJ0IHBvaW50XG5cdCAqIEBwYXJhbSAge2FycmF5fSBbYnV0dG9uc10gUmVjdXJzaXZlIG9ubHkgLSBCdXR0b25zIGFycmF5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZHJhdzogZnVuY3Rpb24gKCBjb250YWluZXIsIGJ1dHRvbnMgKVxuXHR7XG5cdFx0aWYgKCAhIGNvbnRhaW5lciApIHtcblx0XHRcdGNvbnRhaW5lciA9IHRoaXMuZG9tLmNvbnRhaW5lcjtcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLnMuYnV0dG9ucztcblx0XHR9XG5cblx0XHRjb250YWluZXIuY2hpbGRyZW4oKS5kZXRhY2goKTtcblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZCggYnV0dG9uc1tpXS5pbnNlcnRlciApO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZCggJyAnICk7XG5cblx0XHRcdGlmICggYnV0dG9uc1tpXS5idXR0b25zICYmIGJ1dHRvbnNbaV0uYnV0dG9ucy5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuX2RyYXcoIGJ1dHRvbnNbaV0uY29sbGVjdGlvbiwgYnV0dG9uc1tpXS5idXR0b25zICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYnV0dG9ucyBmcm9tIGFuIGFycmF5IG9mIGJ1dHRvbnNcblx0ICogQHBhcmFtICB7YXJyYXl9IGF0dGFjaFRvIEJ1dHRvbnMgYXJyYXkgdG8gYXR0YWNoIHRvXG5cdCAqIEBwYXJhbSAge29iamVjdH0gYnV0dG9uIEJ1dHRvbiBkZWZpbml0aW9uXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW59IGluQ29sbGVjdGlvbiB0cnVlIGlmIHRoZSBidXR0b24gaXMgaW4gYSBjb2xsZWN0aW9uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZXhwYW5kQnV0dG9uOiBmdW5jdGlvbiAoIGF0dGFjaFRvLCBidXR0b24sIGluQ29sbGVjdGlvbiwgYXR0YWNoUG9pbnQgKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBidXR0b25Db3VudGVyID0gMDtcblx0XHR2YXIgYnV0dG9ucyA9ICEgQXJyYXkuaXNBcnJheSggYnV0dG9uICkgP1xuXHRcdFx0WyBidXR0b24gXSA6XG5cdFx0XHRidXR0b247XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciBjb25mID0gdGhpcy5fcmVzb2x2ZUV4dGVuZHMoIGJ1dHRvbnNbaV0gKTtcblxuXHRcdFx0aWYgKCAhIGNvbmYgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBhbiBhcnJheSwgdGhlbiBleHBhbmQgdGhlIGJ1dHRvbnMgYXQgdGhpc1xuXHRcdFx0Ly8gcG9pbnRcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggY29uZiApICkge1xuXHRcdFx0XHR0aGlzLl9leHBhbmRCdXR0b24oIGF0dGFjaFRvLCBjb25mLCBpbkNvbGxlY3Rpb24sIGF0dGFjaFBvaW50ICk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYnVpbHQgPSB0aGlzLl9idWlsZEJ1dHRvbiggY29uZiwgaW5Db2xsZWN0aW9uICk7XG5cdFx0XHRpZiAoICEgYnVpbHQgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0dGFjaFBvaW50ICE9PSB1bmRlZmluZWQgJiYgYXR0YWNoUG9pbnQgIT09IG51bGwgKSB7XG5cdFx0XHRcdGF0dGFjaFRvLnNwbGljZSggYXR0YWNoUG9pbnQsIDAsIGJ1aWx0ICk7XG5cdFx0XHRcdGF0dGFjaFBvaW50Kys7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXR0YWNoVG8ucHVzaCggYnVpbHQgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWlsdC5jb25mLmJ1dHRvbnMgKSB7XG5cdFx0XHRcdGJ1aWx0LmNvbGxlY3Rpb24gPSAkKCc8Jyt0aGlzLmMuZG9tLmNvbGxlY3Rpb24udGFnKycvPicpO1xuXG5cdFx0XHRcdGJ1aWx0LmNvbmYuX2NvbGxlY3Rpb24gPSBidWlsdC5jb2xsZWN0aW9uO1xuXG5cdFx0XHRcdHRoaXMuX2V4cGFuZEJ1dHRvbiggYnVpbHQuYnV0dG9ucywgYnVpbHQuY29uZi5idXR0b25zLCB0cnVlLCBhdHRhY2hQb2ludCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbml0IGNhbGwgaXMgbWFkZSBoZXJlLCByYXRoZXIgdGhhbiBidWlsZEJ1dHRvbiBhcyBpdCBuZWVkcyB0b1xuXHRcdFx0Ly8gYmUgc2VsZWN0YWJsZSwgYW5kIGZvciB0aGF0IGl0IG5lZWRzIHRvIGJlIGluIHRoZSBidXR0b25zIGFycmF5XG5cdFx0XHRpZiAoIGNvbmYuaW5pdCApIHtcblx0XHRcdFx0Y29uZi5pbml0LmNhbGwoIGR0LmJ1dHRvbiggYnVpbHQubm9kZSApLCBkdCwgJChidWlsdC5ub2RlKSwgY29uZiApO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b25Db3VudGVyKys7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW5kaXZpZHVhbCBidXR0b25cblx0ICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgICAgICAgICAgICBSZXNvbHZlZCBidXR0b24gY29uZmlndXJhdGlvblxuXHQgKiBAcGFyYW0gIHtib29sZWFufSBpbkNvbGxlY3Rpb24gYHRydWVgIGlmIGEgY29sbGVjdGlvbiBidXR0b25cblx0ICogQHJldHVybiB7alF1ZXJ5fSBDcmVhdGVkIGJ1dHRvbiBub2RlIChqUXVlcnkpXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYnVpbGRCdXR0b246IGZ1bmN0aW9uICggY29uZmlnLCBpbkNvbGxlY3Rpb24gKVxuXHR7XG5cdFx0dmFyIGJ1dHRvbkRvbSA9IHRoaXMuYy5kb20uYnV0dG9uO1xuXHRcdHZhciBsaW5lckRvbSA9IHRoaXMuYy5kb20uYnV0dG9uTGluZXI7XG5cdFx0dmFyIGNvbGxlY3Rpb25Eb20gPSB0aGlzLmMuZG9tLmNvbGxlY3Rpb247XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciB0ZXh0ID0gZnVuY3Rpb24gKCBvcHQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdG9wdCggZHQsIGJ1dHRvbiwgY29uZmlnICkgOlxuXHRcdFx0XHRvcHQ7XG5cdFx0fTtcblxuXHRcdGlmICggaW5Db2xsZWN0aW9uICYmIGNvbGxlY3Rpb25Eb20uYnV0dG9uICkge1xuXHRcdFx0YnV0dG9uRG9tID0gY29sbGVjdGlvbkRvbS5idXR0b247XG5cdFx0fVxuXG5cdFx0aWYgKCBpbkNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbkRvbS5idXR0b25MaW5lciApIHtcblx0XHRcdGxpbmVyRG9tID0gY29sbGVjdGlvbkRvbS5idXR0b25MaW5lcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgYnV0dG9uIGlzIGF2YWlsYWJsZSBiYXNlZCBvbiB3aGF0ZXZlciByZXF1aXJlbWVudHNcblx0XHQvLyBpdCBoYXMuIEZvciBleGFtcGxlLCBQREYgYnV0dG9uIHJlcXVpcmUgcGRmbWFrZVxuXHRcdGlmICggY29uZmlnLmF2YWlsYWJsZSAmJiAhIGNvbmZpZy5hdmFpbGFibGUoIGR0LCBjb25maWcgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24gKCBlLCBkdCwgYnV0dG9uLCBjb25maWcgKSB7XG5cdFx0XHRjb25maWcuYWN0aW9uLmNhbGwoIGR0LmJ1dHRvbiggYnV0dG9uICksIGUsIGR0LCBidXR0b24sIGNvbmZpZyApO1xuXG5cdFx0XHQkKGR0LnRhYmxlKCkubm9kZSgpKS50cmlnZ2VySGFuZGxlciggJ2J1dHRvbnMtYWN0aW9uLmR0JywgW1xuXHRcdFx0XHRkdC5idXR0b24oIGJ1dHRvbiApLCBkdCwgYnV0dG9uLCBjb25maWcgXG5cdFx0XHRdICk7XG5cdFx0fTtcblxuXHRcdHZhciB0YWcgPSBjb25maWcudGFnIHx8IGJ1dHRvbkRvbS50YWc7XG5cdFx0dmFyIGNsaWNrQmx1cnMgPSBjb25maWcuY2xpY2tCbHVycyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5jbGlja0JsdXJzXG5cdFx0dmFyIGJ1dHRvbiA9ICQoJzwnK3RhZysnLz4nKVxuXHRcdFx0LmFkZENsYXNzKCBidXR0b25Eb20uY2xhc3NOYW1lIClcblx0XHRcdC5hdHRyKCAndGFiaW5kZXgnLCB0aGlzLnMuZHQuc2V0dGluZ3MoKVswXS5pVGFiSW5kZXggKVxuXHRcdFx0LmF0dHIoICdhcmlhLWNvbnRyb2xzJywgdGhpcy5zLmR0LnRhYmxlKCkubm9kZSgpLmlkIClcblx0XHRcdC5vbiggJ2NsaWNrLmR0YicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRpZiAoICEgYnV0dG9uLmhhc0NsYXNzKCBidXR0b25Eb20uZGlzYWJsZWQgKSAmJiBjb25maWcuYWN0aW9uICkge1xuXHRcdFx0XHRcdGFjdGlvbiggZSwgZHQsIGJ1dHRvbiwgY29uZmlnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIGNsaWNrQmx1cnMgKSB7XG5cdFx0XHRcdFx0YnV0dG9uLnRyaWdnZXIoJ2JsdXInKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQub24oICdrZXl1cC5kdGInLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PT0gMTMgKSB7XG5cdFx0XHRcdFx0aWYgKCAhIGJ1dHRvbi5oYXNDbGFzcyggYnV0dG9uRG9tLmRpc2FibGVkICkgJiYgY29uZmlnLmFjdGlvbiApIHtcblx0XHRcdFx0XHRcdGFjdGlvbiggZSwgZHQsIGJ1dHRvbiwgY29uZmlnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIGBhYCB0YWdzIGFjdCBsaWtlIGEgbGlua1xuXHRcdGlmICggdGFnLnRvTG93ZXJDYXNlKCkgPT09ICdhJyApIHtcblx0XHRcdGJ1dHRvbi5hdHRyKCAnaHJlZicsICcjJyApO1xuXHRcdH1cblxuXHRcdC8vIEJ1dHRvbiB0YWdzIHNob3VsZCBoYXZlIGB0eXBlPWJ1dHRvbmAgc28gdGhleSBkb24ndCBoYXZlIGFueSBkZWZhdWx0IGJlaGF2aW91clxuXHRcdGlmICggdGFnLnRvTG93ZXJDYXNlKCkgPT09ICdidXR0b24nICkge1xuXHRcdFx0YnV0dG9uLmF0dHIoICd0eXBlJywgJ2J1dHRvbicgKTtcblx0XHR9XG5cblx0XHRpZiAoIGxpbmVyRG9tLnRhZyApIHtcblx0XHRcdHZhciBsaW5lciA9ICQoJzwnK2xpbmVyRG9tLnRhZysnLz4nKVxuXHRcdFx0XHQuaHRtbCggdGV4dCggY29uZmlnLnRleHQgKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggbGluZXJEb20uY2xhc3NOYW1lICk7XG5cblx0XHRcdGlmICggbGluZXJEb20udGFnLnRvTG93ZXJDYXNlKCkgPT09ICdhJyApIHtcblx0XHRcdFx0bGluZXIuYXR0ciggJ2hyZWYnLCAnIycgKTtcblx0XHRcdH1cblxuXHRcdFx0YnV0dG9uLmFwcGVuZCggbGluZXIgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRidXR0b24uaHRtbCggdGV4dCggY29uZmlnLnRleHQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggY29uZmlnLmVuYWJsZWQgPT09IGZhbHNlICkge1xuXHRcdFx0YnV0dG9uLmFkZENsYXNzKCBidXR0b25Eb20uZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy5jbGFzc05hbWUgKSB7XG5cdFx0XHRidXR0b24uYWRkQ2xhc3MoIGNvbmZpZy5jbGFzc05hbWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy50aXRsZUF0dHIgKSB7XG5cdFx0XHRidXR0b24uYXR0ciggJ3RpdGxlJywgdGV4dCggY29uZmlnLnRpdGxlQXR0ciApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBjb25maWcuYXR0ciApIHtcblx0XHRcdGJ1dHRvbi5hdHRyKCBjb25maWcuYXR0ciApO1xuXHRcdH1cblxuXHRcdGlmICggISBjb25maWcubmFtZXNwYWNlICkge1xuXHRcdFx0Y29uZmlnLm5hbWVzcGFjZSA9ICcuZHQtYnV0dG9uLScrKF9idXR0b25Db3VudGVyKyspO1xuXHRcdH1cblxuXHRcdHZhciBidXR0b25Db250YWluZXIgPSB0aGlzLmMuZG9tLmJ1dHRvbkNvbnRhaW5lcjtcblx0XHR2YXIgaW5zZXJ0ZXI7XG5cdFx0aWYgKCBidXR0b25Db250YWluZXIgJiYgYnV0dG9uQ29udGFpbmVyLnRhZyApIHtcblx0XHRcdGluc2VydGVyID0gJCgnPCcrYnV0dG9uQ29udGFpbmVyLnRhZysnLz4nKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGJ1dHRvbkNvbnRhaW5lci5jbGFzc05hbWUgKVxuXHRcdFx0XHQuYXBwZW5kKCBidXR0b24gKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpbnNlcnRlciA9IGJ1dHRvbjtcblx0XHR9XG5cblx0XHR0aGlzLl9hZGRLZXkoIGNvbmZpZyApO1xuXG5cdFx0Ly8gU3R5bGUgaW50ZWdyYXRpb24gY2FsbGJhY2sgZm9yIERPTSBtYW5pcHVsYXRpb25cblx0XHQvLyBOb3RlIHRoYXQgdGhpcyBpcyBfbm90XyBkb2N1bWVudGVkLiBJdCBpcyBjdXJyZW50bHlcblx0XHQvLyBmb3Igc3R5bGUgaW50ZWdyYXRpb24gb25seVxuXHRcdGlmKCB0aGlzLmMuYnV0dG9uQ3JlYXRlZCApIHtcblx0XHRcdGluc2VydGVyID0gdGhpcy5jLmJ1dHRvbkNyZWF0ZWQoIGNvbmZpZywgaW5zZXJ0ZXIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29uZjogICAgICAgICBjb25maWcsXG5cdFx0XHRub2RlOiAgICAgICAgIGJ1dHRvbi5nZXQoMCksXG5cdFx0XHRpbnNlcnRlcjogICAgIGluc2VydGVyLFxuXHRcdFx0YnV0dG9uczogICAgICBbXSxcblx0XHRcdGluQ29sbGVjdGlvbjogaW5Db2xsZWN0aW9uLFxuXHRcdFx0Y29sbGVjdGlvbjogICBudWxsXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBidXR0b24gb2JqZWN0IGZyb20gYSBub2RlIChyZWN1cnNpdmUpXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgQnV0dG9uIG5vZGVcblx0ICogQHBhcmFtICB7YXJyYXl9IFtidXR0b25zXSBCdXR0b24gYXJyYXksIHVzZXMgYmFzZSBpZiBub3QgZGVmaW5lZFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IEJ1dHRvbiBvYmplY3Rcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9ub2RlVG9CdXR0b246IGZ1bmN0aW9uICggbm9kZSwgYnV0dG9ucyApXG5cdHtcblx0XHRpZiAoICEgYnV0dG9ucyApIHtcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLnMuYnV0dG9ucztcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYnV0dG9uc1tpXS5ub2RlID09PSBub2RlICkge1xuXHRcdFx0XHRyZXR1cm4gYnV0dG9uc1tpXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b25zW2ldLmJ1dHRvbnMubGVuZ3RoICkge1xuXHRcdFx0XHR2YXIgcmV0ID0gdGhpcy5fbm9kZVRvQnV0dG9uKCBub2RlLCBidXR0b25zW2ldLmJ1dHRvbnMgKTtcblxuXHRcdFx0XHRpZiAoIHJldCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgY29udGFpbmVyIGFycmF5IGZvciBhIGJ1dHRvbiBmcm9tIGEgYnV0dG9uIG5vZGUgKHJlY3Vyc2l2ZSlcblx0ICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxuXHQgKiBAcGFyYW0gIHthcnJheX0gW2J1dHRvbnNdIEJ1dHRvbiBhcnJheSwgdXNlcyBiYXNlIGlmIG5vdCBkZWZpbmVkXG5cdCAqIEByZXR1cm4ge2FycmF5fSBCdXR0b24ncyBob3N0IGFycmF5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbm9kZVRvSG9zdDogZnVuY3Rpb24gKCBub2RlLCBidXR0b25zIClcblx0e1xuXHRcdGlmICggISBidXR0b25zICkge1xuXHRcdFx0YnV0dG9ucyA9IHRoaXMucy5idXR0b25zO1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBidXR0b25zW2ldLm5vZGUgPT09IG5vZGUgKSB7XG5cdFx0XHRcdHJldHVybiBidXR0b25zO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbnNbaV0uYnV0dG9ucy5sZW5ndGggKSB7XG5cdFx0XHRcdHZhciByZXQgPSB0aGlzLl9ub2RlVG9Ib3N0KCBub2RlLCBidXR0b25zW2ldLmJ1dHRvbnMgKTtcblxuXHRcdFx0XHRpZiAoIHJldCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYSBrZXkgcHJlc3MgLSBkZXRlcm1pbmUgaWYgYW55IGJ1dHRvbidzIGtleSBjb25maWd1cmVkIG1hdGNoZXNcblx0ICogd2hhdCB3YXMgdHlwZWQgYW5kIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiBzby5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjaGFyYWN0ZXIgVGhlIGNoYXJhY3RlciBwcmVzc2VkXG5cdCAqIEBwYXJhbSAge29iamVjdH0gZSBLZXkgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjYWxsXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfa2V5cHJlc3M6IGZ1bmN0aW9uICggY2hhcmFjdGVyLCBlIClcblx0e1xuXHRcdC8vIENoZWNrIGlmIHRoaXMgYnV0dG9uIHByZXNzIGFscmVhZHkgYWN0aXZhdGVkIG9uIGFub3RoZXIgaW5zdGFuY2Ugb2YgQnV0dG9uc1xuXHRcdGlmICggZS5fYnV0dG9uc0hhbmRsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggY29uZiwgbm9kZSApIHtcblx0XHRcdGlmICggISBjb25mLmtleSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbmYua2V5ID09PSBjaGFyYWN0ZXIgKSB7XG5cdFx0XHRcdGUuX2J1dHRvbnNIYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0JChub2RlKS5jbGljaygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggY29uZi5rZXkgKSApIHtcblx0XHRcdFx0aWYgKCBjb25mLmtleS5rZXkgIT09IGNoYXJhY3RlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNvbmYua2V5LnNoaWZ0S2V5ICYmICEgZS5zaGlmdEtleSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNvbmYua2V5LmFsdEtleSAmJiAhIGUuYWx0S2V5ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY29uZi5rZXkuY3RybEtleSAmJiAhIGUuY3RybEtleSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNvbmYua2V5Lm1ldGFLZXkgJiYgISBlLm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFkZSBpdCB0aGlzIGZhciAtIGl0IGlzIGdvb2Rcblx0XHRcdFx0ZS5fYnV0dG9uc0hhbmRsZWQgPSB0cnVlO1xuXHRcdFx0XHQkKG5vZGUpLmNsaWNrKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciByZWN1cnNlID0gZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHJ1biggYVtpXS5jb25mLCBhW2ldLm5vZGUgKTtcblxuXHRcdFx0XHRpZiAoIGFbaV0uYnV0dG9ucy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmVjdXJzZSggYVtpXS5idXR0b25zICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmVjdXJzZSggdGhpcy5zLmJ1dHRvbnMgKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEga2V5IGZyb20gdGhlIGtleSBsaXN0ZW5lciBmb3IgdGhpcyBpbnN0YW5jZSAodG8gYmUgdXNlZCB3aGVuIGFcblx0ICogYnV0dG9uIGlzIHJlbW92ZWQpXG5cdCAqIEBwYXJhbSAge29iamVjdH0gY29uZiBCdXR0b24gY29uZmlndXJhdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3JlbW92ZUtleTogZnVuY3Rpb24gKCBjb25mIClcblx0e1xuXHRcdGlmICggY29uZi5rZXkgKSB7XG5cdFx0XHR2YXIgY2hhcmFjdGVyID0gJC5pc1BsYWluT2JqZWN0KCBjb25mLmtleSApID9cblx0XHRcdFx0Y29uZi5rZXkua2V5IDpcblx0XHRcdFx0Y29uZi5rZXk7XG5cblx0XHRcdC8vIFJlbW92ZSBvbmx5IG9uZSBjaGFyYWN0ZXIsIGFzIG11bHRpcGxlIGJ1dHRvbnMgY291bGQgaGF2ZSB0aGVcblx0XHRcdC8vIHNhbWUgbGlzdGVuaW5nIGtleVxuXHRcdFx0dmFyIGEgPSB0aGlzLnMubGlzdGVuS2V5cy5zcGxpdCgnJyk7XG5cdFx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCBjaGFyYWN0ZXIsIGEgKTtcblx0XHRcdGEuc3BsaWNlKCBpZHgsIDEgKTtcblx0XHRcdHRoaXMucy5saXN0ZW5LZXlzID0gYS5qb2luKCcnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlc29sdmUgYSBidXR0b24gY29uZmlndXJhdGlvblxuXHQgKiBAcGFyYW0gIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBjb25mIEJ1dHRvbiBjb25maWcgdG8gcmVzb2x2ZVxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IEJ1dHRvbiBjb25maWd1cmF0aW9uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUV4dGVuZHM6IGZ1bmN0aW9uICggY29uZiApXG5cdHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGksIGllbjtcblx0XHR2YXIgdG9Db25mT2JqZWN0ID0gZnVuY3Rpb24gKCBiYXNlICkge1xuXHRcdFx0dmFyIGxvb3AgPSAwO1xuXG5cdFx0XHQvLyBMb29wIHVudGlsIHdlIGhhdmUgcmVzb2x2ZWQgdG8gYSBidXR0b24gY29uZmlndXJhdGlvbiwgb3IgYW5cblx0XHRcdC8vIGFycmF5IG9mIGJ1dHRvbiBjb25maWd1cmF0aW9ucyAod2hpY2ggd2lsbCBiZSBpdGVyYXRlZFxuXHRcdFx0Ly8gc2VwYXJhdGVseSlcblx0XHRcdHdoaWxlICggISAkLmlzUGxhaW5PYmplY3QoYmFzZSkgJiYgISBBcnJheS5pc0FycmF5KGJhc2UpICkge1xuXHRcdFx0XHRpZiAoIGJhc2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHR5cGVvZiBiYXNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGJhc2UgPSBiYXNlKCBkdCwgY29uZiApO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGJhc2UgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgYmFzZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aWYgKCAhIF9kdEJ1dHRvbnNbIGJhc2UgXSApIHtcblx0XHRcdFx0XHRcdHRocm93ICdVbmtub3duIGJ1dHRvbiB0eXBlOiAnK2Jhc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YmFzZSA9IF9kdEJ1dHRvbnNbIGJhc2UgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvb3ArKztcblx0XHRcdFx0aWYgKCBsb29wID4gMzAgKSB7XG5cdFx0XHRcdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IG1pc2NvbmZpZ3VyYXRpb24ga2lsbGluZyB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdHRocm93ICdCdXR0b25zOiBUb28gbWFueSBpdGVyYXRpb25zJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSggYmFzZSApID9cblx0XHRcdFx0YmFzZSA6XG5cdFx0XHRcdCQuZXh0ZW5kKCB7fSwgYmFzZSApO1xuXHRcdH07XG5cblx0XHRjb25mID0gdG9Db25mT2JqZWN0KCBjb25mICk7XG5cblx0XHR3aGlsZSAoIGNvbmYgJiYgY29uZi5leHRlbmQgKSB7XG5cdFx0XHQvLyBVc2UgYHRvQ29uZk9iamVjdGAgaW4gY2FzZSB0aGUgYnV0dG9uIGRlZmluaXRpb24gYmVpbmcgZXh0ZW5kZWRcblx0XHRcdC8vIGlzIGl0c2VsZiBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXG5cdFx0XHRpZiAoICEgX2R0QnV0dG9uc1sgY29uZi5leHRlbmQgXSApIHtcblx0XHRcdFx0dGhyb3cgJ0Nhbm5vdCBleHRlbmQgdW5rbm93biBidXR0b24gdHlwZTogJytjb25mLmV4dGVuZDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG9iakFycmF5ID0gdG9Db25mT2JqZWN0KCBfZHRCdXR0b25zWyBjb25mLmV4dGVuZCBdICk7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iakFycmF5ICkgKSB7XG5cdFx0XHRcdHJldHVybiBvYmpBcnJheTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIG9iakFycmF5ICkge1xuXHRcdFx0XHQvLyBUaGlzIGlzIGEgbGl0dGxlIGJydXRhbCBhcyBpdCBtaWdodCBiZSBwb3NzaWJsZSB0byBoYXZlIGFcblx0XHRcdFx0Ly8gdmFsaWQgYnV0dG9uIHdpdGhvdXQgdGhlIGV4dGVuZCwgYnV0IGlmIHRoZXJlIGlzIG5vIGV4dGVuZFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBob3N0IGJ1dHRvbiB3b3VsZCBiZSBhY3RpbmcgaW4gYW4gdW5kZWZpbmVkIHN0YXRlXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3Rhc2ggdGhlIGN1cnJlbnQgY2xhc3MgbmFtZVxuXHRcdFx0dmFyIG9yaWdpbmFsQ2xhc3NOYW1lID0gb2JqQXJyYXkuY2xhc3NOYW1lO1xuXG5cdFx0XHRjb25mID0gJC5leHRlbmQoIHt9LCBvYmpBcnJheSwgY29uZiApO1xuXG5cdFx0XHQvLyBUaGUgZXh0ZW5kIHdpbGwgaGF2ZSBvdmVyd3JpdHRlbiB0aGUgb3JpZ2luYWwgY2xhc3MgbmFtZSBpZiB0aGVcblx0XHRcdC8vIGBjb25mYCBvYmplY3QgYWxzbyBhc3NpZ25lZCBhIGNsYXNzLCBidXQgd2Ugd2FudCB0byBjb25jYXRlbmF0ZVxuXHRcdFx0Ly8gdGhlbSBzbyB0aGV5IGFyZSBsaXN0IHRoYXQgaXMgY29tYmluZWQgZnJvbSBhbGwgZXh0ZW5kZWQgYnV0dG9uc1xuXHRcdFx0aWYgKCBvcmlnaW5hbENsYXNzTmFtZSAmJiBjb25mLmNsYXNzTmFtZSAhPT0gb3JpZ2luYWxDbGFzc05hbWUgKSB7XG5cdFx0XHRcdGNvbmYuY2xhc3NOYW1lID0gb3JpZ2luYWxDbGFzc05hbWUrJyAnK2NvbmYuY2xhc3NOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXR0b25zIHRvIGJlIGFkZGVkIHRvIGEgY29sbGVjdGlvbiAgLWdpdmVzIHRoZSBhYmlsaXR5IHRvIGRlZmluZVxuXHRcdFx0Ly8gaWYgYnV0dG9ucyBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIGNvbGxlY3Rpb25cblx0XHRcdHZhciBwb3N0Zml4QnV0dG9ucyA9IGNvbmYucG9zdGZpeEJ1dHRvbnM7XG5cdFx0XHRpZiAoIHBvc3RmaXhCdXR0b25zICkge1xuXHRcdFx0XHRpZiAoICEgY29uZi5idXR0b25zICkge1xuXHRcdFx0XHRcdGNvbmYuYnV0dG9ucyA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cG9zdGZpeEJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0Y29uZi5idXR0b25zLnB1c2goIHBvc3RmaXhCdXR0b25zW2ldICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25mLnBvc3RmaXhCdXR0b25zID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHByZWZpeEJ1dHRvbnMgPSBjb25mLnByZWZpeEJ1dHRvbnM7XG5cdFx0XHRpZiAoIHByZWZpeEJ1dHRvbnMgKSB7XG5cdFx0XHRcdGlmICggISBjb25mLmJ1dHRvbnMgKSB7XG5cdFx0XHRcdFx0Y29uZi5idXR0b25zID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1wcmVmaXhCdXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbmYuYnV0dG9ucy5zcGxpY2UoIGksIDAsIHByZWZpeEJ1dHRvbnNbaV0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbmYucHJlZml4QnV0dG9ucyA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsdGhvdWdoIHdlIHdhbnQgdGhlIGBjb25mYCBvYmplY3QgdG8gb3ZlcndyaXRlIGFsbW9zdCBhbGwgb2Zcblx0XHRcdC8vIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVpbmcgZXh0ZW5kZWQsIHRoZSBgZXh0ZW5kYFxuXHRcdFx0Ly8gcHJvcGVydHkgc2hvdWxkIGNvbWUgZnJvbSB0aGUgb2JqZWN0IGJlaW5nIGV4dGVuZGVkXG5cdFx0XHRjb25mLmV4dGVuZCA9IG9iakFycmF5LmV4dGVuZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29uZjtcblx0fSxcblxuXHQvKipcblx0ICogRGlzcGxheSAoYW5kIHJlcGxhY2UgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgb25lKSBhIHBvcG92ZXIgYXR0YWNoZWQgdG8gYSBidXR0b25cblx0ICogQHBhcmFtIHtzdHJpbmd8bm9kZX0gY29udGVudCBDb250ZW50IHRvIHNob3dcblx0ICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBob3N0QnV0dG9uIERUIEFQSSBpbnN0YW5jZSBvZiB0aGUgYnV0dG9uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbk9wdHMgT3B0aW9ucyAoc2VlIG9iamVjdCBiZWxvdyBmb3IgYWxsIG9wdGlvbnMpXG5cdCAqL1xuXHRfcG9wb3ZlcjogZnVuY3Rpb24gKCBjb250ZW50LCBob3N0QnV0dG9uLCBpbk9wdHMgKSB7XG5cdFx0dmFyIGR0ID0gaG9zdEJ1dHRvbjtcblx0XHR2YXIgYnV0dG9uc1NldHRpbmdzID0gdGhpcy5jO1xuXHRcdHZhciBvcHRpb25zID0gJC5leHRlbmQoIHtcblx0XHRcdGFsaWduOiAnYnV0dG9uLWxlZnQnLCAvLyBidXR0b24tcmlnaHQsIGR0LWNvbnRhaW5lclxuXHRcdFx0YXV0b0Nsb3NlOiBmYWxzZSxcblx0XHRcdGJhY2tncm91bmQ6IHRydWUsXG5cdFx0XHRiYWNrZ3JvdW5kQ2xhc3NOYW1lOiAnZHQtYnV0dG9uLWJhY2tncm91bmQnLFxuXHRcdFx0Y29udGVudENsYXNzTmFtZTogYnV0dG9uc1NldHRpbmdzLmRvbS5jb2xsZWN0aW9uLmNsYXNzTmFtZSxcblx0XHRcdGNvbGxlY3Rpb25MYXlvdXQ6ICcnLFxuXHRcdFx0Y29sbGVjdGlvblRpdGxlOiAnJyxcblx0XHRcdGRyb3B1cDogZmFsc2UsXG5cdFx0XHRmYWRlOiA0MDAsXG5cdFx0XHRyaWdodEFsaWduQ2xhc3NOYW1lOiAnZHQtYnV0dG9uLXJpZ2h0Jyxcblx0XHRcdHRhZzogYnV0dG9uc1NldHRpbmdzLmRvbS5jb2xsZWN0aW9uLnRhZ1xuXHRcdH0sIGluT3B0cyApO1xuXHRcdHZhciBob3N0Tm9kZSA9IGhvc3RCdXR0b24ubm9kZSgpO1xuXG5cdFx0dmFyIGNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0X2ZhZGVPdXQoXG5cdFx0XHRcdCQoJy5kdC1idXR0b24tY29sbGVjdGlvbicpLFxuXHRcdFx0XHRvcHRpb25zLmZhZGUsXG5cdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0XHQkKGR0LmJ1dHRvbnMoICdbYXJpYS1oYXNwb3B1cD1cInRydWVcIl1bYXJpYS1leHBhbmRlZD1cInRydWVcIl0nICkubm9kZXMoKSlcblx0XHRcdFx0LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuXHRcdFx0JCgnZGl2LmR0LWJ1dHRvbi1iYWNrZ3JvdW5kJykub2ZmKCAnY2xpY2suZHRiLWNvbGxlY3Rpb24nICk7XG5cdFx0XHRCdXR0b25zLmJhY2tncm91bmQoIGZhbHNlLCBvcHRpb25zLmJhY2tncm91bmRDbGFzc05hbWUsIG9wdGlvbnMuZmFkZSwgaG9zdE5vZGUgKTtcblxuXHRcdFx0JCgnYm9keScpLm9mZiggJy5kdGItY29sbGVjdGlvbicgKTtcblx0XHRcdGR0Lm9mZiggJ2J1dHRvbnMtYWN0aW9uLmItaW50ZXJuYWwnICk7XG5cdFx0fTtcblxuXHRcdGlmIChjb250ZW50ID09PSBmYWxzZSkge1xuXHRcdFx0Y2xvc2UoKTtcblx0XHR9XG5cblx0XHR2YXIgZXhpc3RpbmdFeHBhbmRlZCA9ICQoZHQuYnV0dG9ucyggJ1thcmlhLWhhc3BvcHVwPVwidHJ1ZVwiXVthcmlhLWV4cGFuZGVkPVwidHJ1ZVwiXScgKS5ub2RlcygpKTtcblx0XHRpZiAoIGV4aXN0aW5nRXhwYW5kZWQubGVuZ3RoICkge1xuXHRcdFx0aG9zdE5vZGUgPSBleGlzdGluZ0V4cGFuZGVkLmVxKDApO1xuXG5cdFx0XHRjbG9zZSgpO1xuXHRcdH1cblxuXHRcdHZhciBkaXNwbGF5ID0gJCgnPGRpdi8+Jylcblx0XHRcdC5hZGRDbGFzcygnZHQtYnV0dG9uLWNvbGxlY3Rpb24nKVxuXHRcdFx0LmFkZENsYXNzKG9wdGlvbnMuY29sbGVjdGlvbkxheW91dClcblx0XHRcdC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG5cdFx0Y29udGVudCA9ICQoY29udGVudClcblx0XHRcdC5hZGRDbGFzcyhvcHRpb25zLmNvbnRlbnRDbGFzc05hbWUpXG5cdFx0XHQuYXR0cigncm9sZScsICdtZW51Jylcblx0XHRcdC5hcHBlbmRUbyhkaXNwbGF5KTtcblxuXHRcdGhvc3ROb2RlLmF0dHIoICdhcmlhLWV4cGFuZGVkJywgJ3RydWUnICk7XG5cblx0XHRpZiAoIGhvc3ROb2RlLnBhcmVudHMoJ2JvZHknKVswXSAhPT0gZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdGhvc3ROb2RlID0gZG9jdW1lbnQuYm9keS5sYXN0Q2hpbGQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmNvbGxlY3Rpb25UaXRsZSApIHtcblx0XHRcdGRpc3BsYXkucHJlcGVuZCgnPGRpdiBjbGFzcz1cImR0LWJ1dHRvbi1jb2xsZWN0aW9uLXRpdGxlXCI+JytvcHRpb25zLmNvbGxlY3Rpb25UaXRsZSsnPC9kaXY+Jyk7XG5cdFx0fVxuXG5cdFx0X2ZhZGVJbiggZGlzcGxheS5pbnNlcnRBZnRlciggaG9zdE5vZGUgKSwgb3B0aW9ucy5mYWRlICk7XG5cblx0XHR2YXIgdGFibGVDb250YWluZXIgPSAkKCBob3N0QnV0dG9uLnRhYmxlKCkuY29udGFpbmVyKCkgKTtcblx0XHR2YXIgcG9zaXRpb24gPSBkaXNwbGF5LmNzcyggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmFsaWduID09PSAnZHQtY29udGFpbmVyJyApIHtcblx0XHRcdGhvc3ROb2RlID0gaG9zdE5vZGUucGFyZW50KCk7XG5cdFx0XHRkaXNwbGF5LmNzcygnd2lkdGgnLCB0YWJsZUNvbnRhaW5lci53aWR0aCgpKTtcblx0XHR9XG5cblx0XHQvLyBBbGlnbiB0aGUgcG9wb3ZlciByZWxhdGl2ZSB0byB0aGUgRGF0YVRhYmxlcyBjb250YWluZXJcblx0XHQvLyBVc2VmdWwgZm9yIHdpZGUgcG9wb3ZlcnMgc3VjaCBhcyBTZWFyY2hQYW5lc1xuXHRcdGlmIChwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuXHRcdFx0Ly8gQWxpZ24gcmVsYXRpdmUgdG8gdGhlIGhvc3QgYnV0dG9uXG5cdFx0XHR2YXIgaG9zdFBvc2l0aW9uID0gaG9zdE5vZGUucG9zaXRpb24oKTtcblx0XHRcdHZhciBidXR0b25Qb3NpdGlvbiA9ICQoaG9zdEJ1dHRvbi5ub2RlKCkpLnBvc2l0aW9uKCk7XG5cblx0XHRcdGRpc3BsYXkuY3NzKCB7XG5cdFx0XHRcdHRvcDogYnV0dG9uUG9zaXRpb24udG9wICsgaG9zdE5vZGUub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0bGVmdDogaG9zdFBvc2l0aW9uLmxlZnRcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG92ZXJmbG93IHdoZW4gcG9zaXRpb25lZCBiZW5lYXRoXG5cdFx0XHR2YXIgY29sbGVjdGlvbkhlaWdodCA9IGRpc3BsYXkub3V0ZXJIZWlnaHQoKTtcblx0XHRcdHZhciB0YWJsZUJvdHRvbSA9IHRhYmxlQ29udGFpbmVyLm9mZnNldCgpLnRvcCArIHRhYmxlQ29udGFpbmVyLmhlaWdodCgpO1xuXHRcdFx0dmFyIGxpc3RCb3R0b20gPSBidXR0b25Qb3NpdGlvbi50b3AgKyBob3N0Tm9kZS5vdXRlckhlaWdodCgpICsgY29sbGVjdGlvbkhlaWdodDtcblx0XHRcdHZhciBib3R0b21PdmVyZmxvdyA9IGxpc3RCb3R0b20gLSB0YWJsZUJvdHRvbTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG92ZXJmbG93IHdoZW4gcG9zaXRpb25lZCBhYm92ZVxuXHRcdFx0dmFyIGxpc3RUb3AgPSBidXR0b25Qb3NpdGlvbi50b3AgLSBjb2xsZWN0aW9uSGVpZ2h0O1xuXHRcdFx0dmFyIHRhYmxlVG9wID0gdGFibGVDb250YWluZXIub2Zmc2V0KCkudG9wO1xuXHRcdFx0dmFyIHRvcE92ZXJmbG93ID0gdGFibGVUb3AgLSBsaXN0VG9wO1xuXG5cdFx0XHQvLyBpZiBib3R0b20gb3ZlcmZsb3cgaXMgbGFyZ2VyLCBtb3ZlIHRvIHRoZSB0b3AgYmVjYXVzZSBpdCBmaXRzIGJldHRlciwgb3IgaWYgZHJvcHVwIGlzIHJlcXVlc3RlZFxuXHRcdFx0dmFyIG1vdmVUb3AgPSBidXR0b25Qb3NpdGlvbi50b3AgLSBjb2xsZWN0aW9uSGVpZ2h0IC0gNTtcblx0XHRcdGlmICggKGJvdHRvbU92ZXJmbG93ID4gdG9wT3ZlcmZsb3cgfHwgb3B0aW9ucy5kcm9wdXApICYmIC1tb3ZlVG9wIDwgdGFibGVUb3AgKSB7XG5cdFx0XHRcdGRpc3BsYXkuY3NzKCAndG9wJywgbW92ZVRvcCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyIChsZWZ0IGFuZCB3aWR0aCAtIGFuZCB0aHVzIGFsc28gcmlnaHQpXG5cdFx0XHR2YXIgdGFibGVMZWZ0ID0gdGFibGVDb250YWluZXIub2Zmc2V0KCkubGVmdDtcblx0XHRcdHZhciB0YWJsZVdpZHRoID0gdGFibGVDb250YWluZXIud2lkdGgoKTtcblx0XHRcdHZhciB0YWJsZVJpZ2h0ID0gdGFibGVMZWZ0ICsgdGFibGVXaWR0aDtcblxuXHRcdFx0Ly8gR2V0IHRoZSBzaXplIG9mIHRoZSBwb3BvdmVyIChsZWZ0IGFuZCB3aWR0aCAtIGFuZCAuLi4pXG5cdFx0XHR2YXIgcG9wb3ZlckxlZnQgPSBkaXNwbGF5Lm9mZnNldCgpLmxlZnQ7XG5cdFx0XHR2YXIgcG9wb3ZlcldpZHRoID0gZGlzcGxheS53aWR0aCgpO1xuXHRcdFx0dmFyIHBvcG92ZXJSaWdodCA9IHBvcG92ZXJMZWZ0ICsgcG9wb3ZlcldpZHRoO1xuXG5cdFx0XHQvLyBHZXQgdGhlIHNpemUgb2YgdGhlIGhvc3QgYnV0dG9ucyAobGVmdCBhbmQgd2lkdGggLSBhbmQgLi4uKVxuXHRcdFx0dmFyIGJ1dHRvbnNMZWZ0ID0gaG9zdE5vZGUub2Zmc2V0KCkubGVmdDtcblx0XHRcdHZhciBidXR0b25zV2lkdGggPSBob3N0Tm9kZS5vdXRlcldpZHRoKClcblx0XHRcdHZhciBidXR0b25zUmlnaHQgPSBidXR0b25zTGVmdCArIGJ1dHRvbnNXaWR0aDtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXNwbGF5Lmhhc0NsYXNzKCBvcHRpb25zLnJpZ2h0QWxpZ25DbGFzc05hbWUgKSB8fFxuXHRcdFx0XHRkaXNwbGF5Lmhhc0NsYXNzKCBvcHRpb25zLmxlZnRBbGlnbkNsYXNzTmFtZSApIHx8XG5cdFx0XHRcdG9wdGlvbnMuYWxpZ24gPT09ICdkdC1jb250YWluZXInXG5cdFx0XHQpe1xuXHRcdFx0XHQvLyBZb3UndmUgdGhlbiBnb3QgYWxsIHRoZSBudW1iZXJzIHlvdSBuZWVkIHRvIGRvIHNvbWUgY2FsY3VsYXRpb25zIGFuZCBpZiBzdGF0ZW1lbnRzLFxuXHRcdFx0XHQvLyAgc28gd2UgY2FuIGRvIHNvbWUgcXVpY2sgSlMgbWF0aHMgYW5kIGFwcGx5IGl0IG9ubHkgb25jZVxuXHRcdFx0XHQvLyBJZiBpdCBoYXMgdGhlIHJpZ2h0IGFsaWduIGNsYXNzIE9SIHRoZSBidXR0b25zIGFyZSByaWdodCBhbGlnbmVkIE9SIHRoZSBidXR0b24gY29udGFpbmVyIGlzIGZsb2F0ZWQgcmlnaHQsXG5cdFx0XHRcdC8vICB0aGVuIGNhbGN1bGF0ZSBsZWZ0IHBvc2l0aW9uIGZvciB0aGUgcG9wb3ZlciB0byBhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgcmlnaHQgaGFuZFxuXHRcdFx0XHQvLyAgc2lkZSBvZiB0aGUgYnV0dG9uIC0gY2hlY2sgdG8gc2VlIGlmIHRoZSBsZWZ0IG9mIHRoZSBwb3BvdmVyIGlzIGluc2lkZSB0aGUgdGFibGUgY29udGFpbmVyLlxuXHRcdFx0XHQvLyBJZiBub3QsIG1vdmUgdGhlIHBvcG92ZXIgc28gaXQgaXMsIGJ1dCBub3QgbW9yZSB0aGFuIGl0IG1lYW5zIHRoYXQgdGhlIHBvcG92ZXIgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSB0YWJsZSBjb250YWluZXJcblx0XHRcdFx0dmFyIHBvcG92ZXJTaHVmZmxlID0gMDtcblx0XHRcdFx0aWYgKCBkaXNwbGF5Lmhhc0NsYXNzKCBvcHRpb25zLnJpZ2h0QWxpZ25DbGFzc05hbWUgKSkge1xuXHRcdFx0XHRcdHBvcG92ZXJTaHVmZmxlID0gYnV0dG9uc1JpZ2h0IC0gcG9wb3ZlclJpZ2h0O1xuXHRcdFx0XHRcdGlmKHRhYmxlTGVmdCA+IChwb3BvdmVyTGVmdCArIHBvcG92ZXJTaHVmZmxlKSl7XG5cdFx0XHRcdFx0XHR2YXIgbGVmdEdhcCA9IHRhYmxlTGVmdCAtIChwb3BvdmVyTGVmdCArIHBvcG92ZXJTaHVmZmxlKTtcblx0XHRcdFx0XHRcdHZhciByaWdodEdhcCA9IHRhYmxlUmlnaHQgLSAocG9wb3ZlclJpZ2h0ICsgcG9wb3ZlclNodWZmbGUpO1xuXHRcdFxuXHRcdFx0XHRcdFx0aWYobGVmdEdhcCA+IHJpZ2h0R2FwKXtcblx0XHRcdFx0XHRcdFx0cG9wb3ZlclNodWZmbGUgKz0gcmlnaHRHYXA7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHBvcG92ZXJTaHVmZmxlICs9IGxlZnRHYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGVsc2UgYXR0ZW1wdCB0byBsZWZ0IGFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBidXR0b24uIFNpbWlsYXIgdG8gYWJvdmUsIGlmIHRoZSBwb3BvdmVyJ3MgcmlnaHQgZ29lcyBwYXN0IHRoZSB0YWJsZSBjb250YWluZXIncyByaWdodCxcblx0XHRcdFx0Ly8gIHRoZW4gbW92ZSBpdCBiYWNrLCBidXQgbm90IHNvIG11Y2ggdGhhdCBpdCBnb2VzIHBhc3QgdGhlIGxlZnQgb2YgdGhlIHRhYmxlIGNvbnRhaW5lclxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRwb3BvdmVyU2h1ZmZsZSA9IHRhYmxlTGVmdCAtIHBvcG92ZXJMZWZ0O1xuXHRcblx0XHRcdFx0XHRpZih0YWJsZVJpZ2h0IDwgKHBvcG92ZXJSaWdodCArIHBvcG92ZXJTaHVmZmxlKSl7XG5cdFx0XHRcdFx0XHR2YXIgbGVmdEdhcCA9IHRhYmxlTGVmdCAtIChwb3BvdmVyTGVmdCArIHBvcG92ZXJTaHVmZmxlKTtcblx0XHRcdFx0XHRcdHZhciByaWdodEdhcCA9IHRhYmxlUmlnaHQgLSAocG9wb3ZlclJpZ2h0ICsgcG9wb3ZlclNodWZmbGUpO1xuXHRcblx0XHRcdFx0XHRcdGlmKGxlZnRHYXAgPiByaWdodEdhcCApe1xuXHRcdFx0XHRcdFx0XHRwb3BvdmVyU2h1ZmZsZSArPSByaWdodEdhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwb3BvdmVyU2h1ZmZsZSArPSBsZWZ0R2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGRpc3BsYXkuY3NzKCdsZWZ0JywgZGlzcGxheS5wb3NpdGlvbigpLmxlZnQgKyBwb3BvdmVyU2h1ZmZsZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIHRvcCA9IGhvc3ROb2RlLm9mZnNldCgpLnRvcFxuXHRcdFx0XHR2YXIgcG9wb3ZlclNodWZmbGUgPSAwO1xuXG5cdFx0XHRcdHBvcG92ZXJTaHVmZmxlID0gb3B0aW9ucy5hbGlnbiA9PT0gJ2J1dHRvbi1yaWdodCdcblx0XHRcdFx0XHQ/IGJ1dHRvbnNSaWdodCAtIHBvcG92ZXJSaWdodFxuXHRcdFx0XHRcdDogYnV0dG9uc0xlZnQgLSBwb3BvdmVyTGVmdDtcblxuXHRcdFx0XHRkaXNwbGF5LmNzcygnbGVmdCcsIGRpc3BsYXkucG9zaXRpb24oKS5sZWZ0ICsgcG9wb3ZlclNodWZmbGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBGaXggcG9zaXRpb24gLSBjZW50cmUgb24gc2NyZWVuXG5cdFx0XHR2YXIgdG9wID0gZGlzcGxheS5oZWlnaHQoKSAvIDI7XG5cdFx0XHRpZiAoIHRvcCA+ICQod2luZG93KS5oZWlnaHQoKSAvIDIgKSB7XG5cdFx0XHRcdHRvcCA9ICQod2luZG93KS5oZWlnaHQoKSAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BsYXkuY3NzKCAnbWFyZ2luVG9wJywgdG9wKi0xICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmJhY2tncm91bmQgKSB7XG5cdFx0XHRCdXR0b25zLmJhY2tncm91bmQoIHRydWUsIG9wdGlvbnMuYmFja2dyb3VuZENsYXNzTmFtZSwgb3B0aW9ucy5mYWRlLCBob3N0Tm9kZSApO1xuXHRcdH1cblxuXHRcdC8vIFRoaXMgaXMgYm9ua2VycywgYnV0IGlmIHdlIGRvbid0IGhhdmUgYSBjbGljayBsaXN0ZW5lciBvbiB0aGVcblx0XHQvLyBiYWNrZ3JvdW5kIGVsZW1lbnQsIGlPUyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGJvZHkgY2xpY2tcblx0XHQvLyBsaXN0ZW5lciBiZWxvdy4gQW4gZW1wdHkgZnVuY3Rpb24gaGVyZSBpcyBhbGwgdGhhdCBpc1xuXHRcdC8vIHJlcXVpcmVkIHRvIG1ha2UgaXQgd29yay4uLlxuXHRcdCQoJ2Rpdi5kdC1idXR0b24tYmFja2dyb3VuZCcpLm9uKCAnY2xpY2suZHRiLWNvbGxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7fSApO1xuXG5cdFx0JCgnYm9keScpXG5cdFx0XHQub24oICdjbGljay5kdGItY29sbGVjdGlvbicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIGFuZFNlbGYgaXMgZGVwcmVjYXRlZCBpbiBqUTEuOCwgYnV0IHdlIHdhbnQgMS43IGNvbXBhdFxuXHRcdFx0XHR2YXIgYmFjayA9ICQuZm4uYWRkQmFjayA/ICdhZGRCYWNrJyA6ICdhbmRTZWxmJztcblx0XHRcdFx0dmFyIHBhcmVudCA9ICQoZS50YXJnZXQpLnBhcmVudCgpWzBdO1xuXG5cdFx0XHRcdGlmICgoICEgJChlLnRhcmdldCkucGFyZW50cygpW2JhY2tdKCkuZmlsdGVyKCBjb250ZW50ICkubGVuZ3RoICAmJiAhJChwYXJlbnQpLmhhc0NsYXNzKCdkdC1idXR0b25zJykpIHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKCdkdC1idXR0b24tYmFja2dyb3VuZCcpKSB7XG5cdFx0XHRcdFx0Y2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQub24oICdrZXl1cC5kdGItY29sbGVjdGlvbicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmICggZS5rZXlDb2RlID09PSAyNyApIHtcblx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMuYXV0b0Nsb3NlICkge1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkdC5vbiggJ2J1dHRvbnMtYWN0aW9uLmItaW50ZXJuYWwnLCBmdW5jdGlvbiAoZSwgYnRuLCBkdCwgbm9kZSkge1xuXHRcdFx0XHRcdGlmICggbm9kZVswXSA9PT0gaG9zdE5vZGVbMF0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNsb3NlKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sIDApO1xuXHRcdH1cblxuXHRcdCQoZGlzcGxheSkudHJpZ2dlcignYnV0dG9ucy1wb3BvdmVyLmR0Jyk7XG5cdH1cbn0gKTtcblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIFN0YXRpY3NcbiAqL1xuXG4vKipcbiAqIFNob3cgLyBoaWRlIGEgYmFja2dyb3VuZCBsYXllciBiZWhpbmQgYSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtib29sZWFufSBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBiYWNrZ3JvdW5kIHNob3VsZCBiZSBzaG93biBvclxuICogICBoaWRkZW4gXG4gKiBAcGFyYW0gIHtzdHJpbmd9IENsYXNzIHRvIGFzc2lnbiB0byB0aGUgYmFja2dyb3VuZFxuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmJhY2tncm91bmQgPSBmdW5jdGlvbiAoIHNob3csIGNsYXNzTmFtZSwgZmFkZSwgaW5zZXJ0UG9pbnQgKSB7XG5cdGlmICggZmFkZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGZhZGUgPSA0MDA7XG5cdH1cblx0aWYgKCAhIGluc2VydFBvaW50ICkge1xuXHRcdGluc2VydFBvaW50ID0gZG9jdW1lbnQuYm9keTtcblx0fVxuXG5cdGlmICggc2hvdyApIHtcblx0XHRfZmFkZUluKFxuXHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0LmFkZENsYXNzKCBjbGFzc05hbWUgKVxuXHRcdFx0XHQuY3NzKCAnZGlzcGxheScsICdub25lJyApXG5cdFx0XHRcdC5pbnNlcnRBZnRlciggaW5zZXJ0UG9pbnQgKSxcblx0XHRcdGZhZGVcblx0XHQpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdF9mYWRlT3V0KFxuXHRcdFx0JCgnZGl2LicrY2xhc3NOYW1lKSxcblx0XHRcdGZhZGUsXG5cdFx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdCQodGhpcylcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApXG5cdFx0XHRcdFx0LnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cbn07XG5cbi8qKlxuICogSW5zdGFuY2Ugc2VsZWN0b3IgLSBzZWxlY3QgQnV0dG9ucyBpbnN0YW5jZXMgYmFzZWQgb24gYW4gaW5zdGFuY2Ugc2VsZWN0b3JcbiAqIHZhbHVlIGZyb20gdGhlIGJ1dHRvbnMgYXNzaWduZWQgdG8gYSBEYXRhVGFibGUuIFRoaXMgaXMgb25seSB1c2VmdWwgaWZcbiAqIG11bHRpcGxlIGluc3RhbmNlcyBhcmUgYXR0YWNoZWQgdG8gYSBEYXRhVGFibGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd8aW50fGFycmF5fSBJbnN0YW5jZSBzZWxlY3RvciAtIHNlZSBgaW5zdGFuY2Utc2VsZWN0b3JgXG4gKiAgIGRvY3VtZW50YXRpb24gb24gdGhlIERhdGFUYWJsZXMgc2l0ZVxuICogQHBhcmFtICB7YXJyYXl9IEJ1dHRvbiBpbnN0YW5jZSBhcnJheSB0aGF0IHdhcyBhdHRhY2hlZCB0byB0aGUgRGF0YVRhYmxlc1xuICogICBzZXR0aW5ncyBvYmplY3RcbiAqIEByZXR1cm4ge2FycmF5fSBCdXR0b25zIGluc3RhbmNlc1xuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmluc3RhbmNlU2VsZWN0b3IgPSBmdW5jdGlvbiAoIGdyb3VwLCBidXR0b25zIClcbntcblx0aWYgKCBncm91cCA9PT0gdW5kZWZpbmVkIHx8IGdyb3VwID09PSBudWxsICkge1xuXHRcdHJldHVybiAkLm1hcCggYnV0dG9ucywgZnVuY3Rpb24gKCB2ICkge1xuXHRcdFx0cmV0dXJuIHYuaW5zdDtcblx0XHR9ICk7XG5cdH1cblxuXHR2YXIgcmV0ID0gW107XG5cdHZhciBuYW1lcyA9ICQubWFwKCBidXR0b25zLCBmdW5jdGlvbiAoIHYgKSB7XG5cdFx0cmV0dXJuIHYubmFtZTtcblx0fSApO1xuXG5cdC8vIEZsYXR0ZW4gdGhlIGdyb3VwIHNlbGVjdG9yIGludG8gYW4gYXJyYXkgb2Ygc2luZ2xlIG9wdGlvbnNcblx0dmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoIGlucHV0ICkge1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggaW5wdXQgKSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1pbnB1dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cHJvY2VzcyggaW5wdXRbaV0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRpZiAoIGlucHV0LmluZGV4T2YoICcsJyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gU3RyaW5nIHNlbGVjdG9yLCBsaXN0IG9mIG5hbWVzXG5cdFx0XHRcdHByb2Nlc3MoIGlucHV0LnNwbGl0KCcsJykgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBTdHJpbmcgc2VsZWN0b3IgaW5kaXZpZHVhbCBuYW1lXG5cdFx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIGlucHV0LnRyaW0oKSwgbmFtZXMgKTtcblxuXHRcdFx0XHRpZiAoIGlkeCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGJ1dHRvbnNbIGlkeCBdLmluc3QgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyApIHtcblx0XHRcdC8vIEluZGV4IHNlbGVjdG9yXG5cdFx0XHRyZXQucHVzaCggYnV0dG9uc1sgaW5wdXQgXS5pbnN0ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0cHJvY2VzcyggZ3JvdXAgKTtcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBCdXR0b24gc2VsZWN0b3IgLSBzZWxlY3Qgb25lIG9yIG1vcmUgYnV0dG9ucyBmcm9tIGEgc2VsZWN0b3IgaW5wdXQgc28gc29tZVxuICogb3BlcmF0aW9uIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhlbS5cbiAqIEBwYXJhbSAge2FycmF5fSBCdXR0b24gaW5zdGFuY2VzIGFycmF5IHRoYXQgdGhlIHNlbGVjdG9yIHNob3VsZCBvcGVyYXRlIG9uXG4gKiBAcGFyYW0gIHtzdHJpbmd8aW50fG5vZGV8alF1ZXJ5fGFycmF5fSBCdXR0b24gc2VsZWN0b3IgLSBzZWVcbiAqICAgYGJ1dHRvbi1zZWxlY3RvcmAgZG9jdW1lbnRhdGlvbiBvbiB0aGUgRGF0YVRhYmxlcyBzaXRlXG4gKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBpbnN0YCBhbmQgYGlkeGAgcHJvcGVydGllcyBvZlxuICogICB0aGUgc2VsZWN0ZWQgYnV0dG9ucyBzbyB5b3Uga25vdyB3aGljaCBpbnN0YW5jZSBlYWNoIGJ1dHRvbiBiZWxvbmdzIHRvLlxuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmJ1dHRvblNlbGVjdG9yID0gZnVuY3Rpb24gKCBpbnN0cywgc2VsZWN0b3IgKVxue1xuXHR2YXIgcmV0ID0gW107XG5cdHZhciBub2RlQnVpbGRlciA9IGZ1bmN0aW9uICggYSwgYnV0dG9ucywgYmFzZUlkeCApIHtcblx0XHR2YXIgYnV0dG9uO1xuXHRcdHZhciBpZHg7XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG5cblx0XHRcdGlmICggYnV0dG9uICkge1xuXHRcdFx0XHRpZHggPSBiYXNlSWR4ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGJhc2VJZHgraSA6XG5cdFx0XHRcdFx0aSsnJztcblxuXHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRub2RlOiBidXR0b24ubm9kZSxcblx0XHRcdFx0XHRuYW1lOiBidXR0b24uY29uZi5uYW1lLFxuXHRcdFx0XHRcdGlkeDogIGlkeFxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBidXR0b24uYnV0dG9ucyApIHtcblx0XHRcdFx0XHRub2RlQnVpbGRlciggYSwgYnV0dG9uLmJ1dHRvbnMsIGlkeCsnLScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzZWxlY3RvciwgaW5zdCApIHtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBidXR0b25zID0gW107XG5cdFx0bm9kZUJ1aWxkZXIoIGJ1dHRvbnMsIGluc3Qucy5idXR0b25zICk7XG5cblx0XHR2YXIgbm9kZXMgPSAkLm1hcCggYnV0dG9ucywgZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiB2Lm5vZGU7XG5cdFx0fSApO1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzZWxlY3RvciApIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgJCApIHtcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNlbGVjdG9yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRydW4oIHNlbGVjdG9yW2ldLCBpbnN0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gbnVsbCB8fCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkIHx8IHNlbGVjdG9yID09PSAnKicgKSB7XG5cdFx0XHQvLyBTZWxlY3QgYWxsXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdGluc3Q6IGluc3QsXG5cdFx0XHRcdFx0bm9kZTogYnV0dG9uc1tpXS5ub2RlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHQvLyBNYWluIGJ1dHRvbiBpbmRleCBzZWxlY3RvclxuXHRcdFx0cmV0LnB1c2goIHtcblx0XHRcdFx0aW5zdDogaW5zdCxcblx0XHRcdFx0bm9kZTogaW5zdC5zLmJ1dHRvbnNbIHNlbGVjdG9yIF0ubm9kZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdGlmICggc2VsZWN0b3IuaW5kZXhPZiggJywnICkgIT09IC0xICkge1xuXHRcdFx0XHQvLyBTcGxpdFxuXHRcdFx0XHR2YXIgYSA9IHNlbGVjdG9yLnNwbGl0KCcsJyk7XG5cblx0XHRcdFx0Zm9yICggaT0wLCBpZW49YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRydW4oIGFbaV0udHJpbSgpLCBpbnN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxlY3Rvci5tYXRjaCggL15cXGQrKFxcLVxcZCspKiQvICkgKSB7XG5cdFx0XHRcdC8vIFN1Yi1idXR0b24gaW5kZXggc2VsZWN0b3Jcblx0XHRcdFx0dmFyIGluZGV4ZXMgPSAkLm1hcCggYnV0dG9ucywgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0XHRyZXR1cm4gdi5pZHg7XG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdGluc3Q6IGluc3QsXG5cdFx0XHRcdFx0bm9kZTogYnV0dG9uc1sgJC5pbkFycmF5KCBzZWxlY3RvciwgaW5kZXhlcyApIF0ubm9kZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZWN0b3IuaW5kZXhPZiggJzpuYW1lJyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gQnV0dG9uIG5hbWUgc2VsZWN0b3Jcblx0XHRcdFx0dmFyIG5hbWUgPSBzZWxlY3Rvci5yZXBsYWNlKCAnOm5hbWUnLCAnJyApO1xuXG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBidXR0b25zW2ldLm5hbWUgPT09IG5hbWUgKSB7XG5cdFx0XHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRpbnN0OiBpbnN0LFxuXHRcdFx0XHRcdFx0XHRub2RlOiBidXR0b25zW2ldLm5vZGVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIG5vZGVzXG5cdFx0XHRcdCQoIG5vZGVzICkuZmlsdGVyKCBzZWxlY3RvciApLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdFx0aW5zdDogaW5zdCxcblx0XHRcdFx0XHRcdG5vZGU6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcgJiYgc2VsZWN0b3Iubm9kZU5hbWUgKSB7XG5cdFx0XHQvLyBOb2RlIHNlbGVjdG9yXG5cdFx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCBzZWxlY3Rvciwgbm9kZXMgKTtcblxuXHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdGluc3Q6IGluc3QsXG5cdFx0XHRcdFx0bm9kZTogbm9kZXNbIGlkeCBdXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49aW5zdHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFyIGluc3QgPSBpbnN0c1tpXTtcblxuXHRcdHJ1biggc2VsZWN0b3IsIGluc3QgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgZnVuY3Rpb24gdXNlZCBmb3IgZm9ybWF0dGluZyBvdXRwdXQgZGF0YS5cbiAqIEBwYXJhbSB7Kn0gc3RyIERhdGEgdG8gc3RyaXBcbiAqL1xuQnV0dG9ucy5zdHJpcERhdGEgPSBmdW5jdGlvbiAoIHN0ciwgY29uZmlnICkge1xuXHRpZiAoIHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnICkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHQvLyBBbHdheXMgcmVtb3ZlIHNjcmlwdCB0YWdzXG5cdHN0ciA9IHN0ci5yZXBsYWNlKCAvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSwgJycgKTtcblxuXHQvLyBBbHdheXMgcmVtb3ZlIGNvbW1lbnRzXG5cdHN0ciA9IHN0ci5yZXBsYWNlKCAvPCFcXC1cXC0uKj9cXC1cXC0+L2csICcnICk7XG5cblx0aWYgKCAhIGNvbmZpZyB8fCBjb25maWcuc3RyaXBIdG1sICkge1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKCAvPFtePl0qPi9nLCAnJyApO1xuXHR9XG5cblx0aWYgKCAhIGNvbmZpZyB8fCBjb25maWcudHJpbSApIHtcblx0XHRzdHIgPSBzdHIucmVwbGFjZSggL15cXHMrfFxccyskL2csICcnICk7XG5cdH1cblxuXHRpZiAoICEgY29uZmlnIHx8IGNvbmZpZy5zdHJpcE5ld2xpbmVzICkge1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKCAvXFxuL2csICcgJyApO1xuXHR9XG5cblx0aWYgKCAhIGNvbmZpZyB8fCBjb25maWcuZGVjb2RlRW50aXRpZXMgKSB7XG5cdFx0X2V4cG9ydFRleHRhcmVhLmlubmVySFRNTCA9IHN0cjtcblx0XHRzdHIgPSBfZXhwb3J0VGV4dGFyZWEudmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIEJ1dHRvbnMgZGVmYXVsdHMuIEZvciBmdWxsIGRvY3VtZW50YXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgZG9jcy9vcHRpb25cbiAqIGRpcmVjdG9yeSBvciB0aGUgRGF0YVRhYmxlcyBzaXRlLlxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9ucy5kZWZhdWx0cyA9IHtcblx0YnV0dG9uczogWyAnY29weScsICdleGNlbCcsICdjc3YnLCAncGRmJywgJ3ByaW50JyBdLFxuXHRuYW1lOiAnbWFpbicsXG5cdHRhYkluZGV4OiAwLFxuXHRkb206IHtcblx0XHRjb250YWluZXI6IHtcblx0XHRcdHRhZzogJ2RpdicsXG5cdFx0XHRjbGFzc05hbWU6ICdkdC1idXR0b25zJ1xuXHRcdH0sXG5cdFx0Y29sbGVjdGlvbjoge1xuXHRcdFx0dGFnOiAnZGl2Jyxcblx0XHRcdGNsYXNzTmFtZTogJydcblx0XHR9LFxuXHRcdGJ1dHRvbjoge1xuXHRcdFx0dGFnOiAnYnV0dG9uJyxcblx0XHRcdGNsYXNzTmFtZTogJ2R0LWJ1dHRvbicsXG5cdFx0XHRhY3RpdmU6ICdhY3RpdmUnLFxuXHRcdFx0ZGlzYWJsZWQ6ICdkaXNhYmxlZCdcblx0XHR9LFxuXHRcdGJ1dHRvbkxpbmVyOiB7XG5cdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdGNsYXNzTmFtZTogJydcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvcm1hdGlvblxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9ucy52ZXJzaW9uID0gJzEuNy4xJztcblxuXG4kLmV4dGVuZCggX2R0QnV0dG9ucywge1xuXHRjb2xsZWN0aW9uOiB7XG5cdFx0dGV4dDogZnVuY3Rpb24gKCBkdCApIHtcblx0XHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy5jb2xsZWN0aW9uJywgJ0NvbGxlY3Rpb24nICk7XG5cdFx0fSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLWNvbGxlY3Rpb24nLFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIGJ1dHRvbiwgY29uZmlnICkge1xuXHRcdFx0YnV0dG9uLmF0dHIoICdhcmlhLWV4cGFuZGVkJywgZmFsc2UgKTtcblx0XHR9LFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCBlLCBkdCwgYnV0dG9uLCBjb25maWcgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRpZiAoIGNvbmZpZy5fY29sbGVjdGlvbi5wYXJlbnRzKCdib2R5JykubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnBvcG92ZXIoZmFsc2UsIGNvbmZpZyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5wb3BvdmVyKGNvbmZpZy5fY29sbGVjdGlvbiwgY29uZmlnKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0dHI6IHtcblx0XHRcdCdhcmlhLWhhc3BvcHVwJzogdHJ1ZVxuXHRcdH1cblx0XHQvLyBBbHNvIHRoZSBwb3BvdmVyIG9wdGlvbnMsIGRlZmluZWQgaW4gQnV0dG9ucy5wb3BvdmVyXG5cdH0sXG5cdGNvcHk6IGZ1bmN0aW9uICggZHQsIGNvbmYgKSB7XG5cdFx0aWYgKCBfZHRCdXR0b25zLmNvcHlIdG1sNSApIHtcblx0XHRcdHJldHVybiAnY29weUh0bWw1Jztcblx0XHR9XG5cdH0sXG5cdGNzdjogZnVuY3Rpb24gKCBkdCwgY29uZiApIHtcblx0XHRpZiAoIF9kdEJ1dHRvbnMuY3N2SHRtbDUgJiYgX2R0QnV0dG9ucy5jc3ZIdG1sNS5hdmFpbGFibGUoIGR0LCBjb25mICkgKSB7XG5cdFx0XHRyZXR1cm4gJ2Nzdkh0bWw1Jztcblx0XHR9XG5cdH0sXG5cdGV4Y2VsOiBmdW5jdGlvbiAoIGR0LCBjb25mICkge1xuXHRcdGlmICggX2R0QnV0dG9ucy5leGNlbEh0bWw1ICYmIF9kdEJ1dHRvbnMuZXhjZWxIdG1sNS5hdmFpbGFibGUoIGR0LCBjb25mICkgKSB7XG5cdFx0XHRyZXR1cm4gJ2V4Y2VsSHRtbDUnO1xuXHRcdH1cblx0fSxcblx0cGRmOiBmdW5jdGlvbiAoIGR0LCBjb25mICkge1xuXHRcdGlmICggX2R0QnV0dG9ucy5wZGZIdG1sNSAmJiBfZHRCdXR0b25zLnBkZkh0bWw1LmF2YWlsYWJsZSggZHQsIGNvbmYgKSApIHtcblx0XHRcdHJldHVybiAncGRmSHRtbDUnO1xuXHRcdH1cblx0fSxcblx0cGFnZUxlbmd0aDogZnVuY3Rpb24gKCBkdCApIHtcblx0XHR2YXIgbGVuZ3RoTWVudSA9IGR0LnNldHRpbmdzKClbMF0uYUxlbmd0aE1lbnU7XG5cdFx0dmFyIHZhbHMgPSBbXTtcblx0XHR2YXIgbGFuZyA9IFtdO1xuXHRcdHZhciB0ZXh0ID0gZnVuY3Rpb24gKCBkdCApIHtcblx0XHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy5wYWdlTGVuZ3RoJywge1xuXHRcdFx0XHRcIi0xXCI6ICdTaG93IGFsbCByb3dzJyxcblx0XHRcdFx0XzogICAgJ1Nob3cgJWQgcm93cydcblx0XHRcdH0sIGR0LnBhZ2UubGVuKCkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydCBmb3IgRGF0YVRhYmxlcyAxLnggMkQgYXJyYXlcblx0XHRpZiAoQXJyYXkuaXNBcnJheSggbGVuZ3RoTWVudVswXSApKSB7XG5cdFx0XHR2YWxzID0gbGVuZ3RoTWVudVswXTtcblx0XHRcdGxhbmcgPSBsZW5ndGhNZW51WzFdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvciAodmFyIGk9MCA7IGk8bGVuZ3RoTWVudS5sZW5ndGggOyBpKyspIHtcblx0XHRcdFx0dmFyIG9wdGlvbiA9IGxlbmd0aE1lbnVbaV07XG5cblx0XHRcdFx0Ly8gU3VwcG9ydCBmb3IgRGF0YVRhYmxlcyAyIG9iamVjdCBpbiB0aGUgYXJyYXlcblx0XHRcdFx0aWYgKCQuaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XG5cdFx0XHRcdFx0dmFscy5wdXNoKG9wdGlvbi52YWx1ZSk7XG5cdFx0XHRcdFx0bGFuZy5wdXNoKG9wdGlvbi5sYWJlbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFscy5wdXNoKG9wdGlvbik7XG5cdFx0XHRcdFx0bGFuZy5wdXNoKG9wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0ZW5kOiAnY29sbGVjdGlvbicsXG5cdFx0XHR0ZXh0OiB0ZXh0LFxuXHRcdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1wYWdlLWxlbmd0aCcsXG5cdFx0XHRhdXRvQ2xvc2U6IHRydWUsXG5cdFx0XHRidXR0b25zOiAkLm1hcCggdmFscywgZnVuY3Rpb24gKCB2YWwsIGkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dGV4dDogbGFuZ1tpXSxcblx0XHRcdFx0XHRjbGFzc05hbWU6ICdidXR0b24tcGFnZS1sZW5ndGgnLFxuXHRcdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24gKCBlLCBkdCApIHtcblx0XHRcdFx0XHRcdGR0LnBhZ2UubGVuKCB2YWwgKS5kcmF3KCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRpbml0OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25mICkge1xuXHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0dmFyIGZuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LmFjdGl2ZSggZHQucGFnZS5sZW4oKSA9PT0gdmFsICk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRkdC5vbiggJ2xlbmd0aC5kdCcrY29uZi5uYW1lc3BhY2UsIGZuICk7XG5cdFx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGVzdHJveTogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZiApIHtcblx0XHRcdFx0XHRcdGR0Lm9mZiggJ2xlbmd0aC5kdCcrY29uZi5uYW1lc3BhY2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9ICksXG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25mICkge1xuXHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdGR0Lm9uKCAnbGVuZ3RoLmR0Jytjb25mLm5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoYXQudGV4dCggY29uZi50ZXh0ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25mICkge1xuXHRcdFx0XHRkdC5vZmYoICdsZW5ndGguZHQnK2NvbmYubmFtZXNwYWNlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIEFQSVxuICpcbiAqIEZvciBjb21wbGV0ZSBkb2N1bWVudGF0aW9uLCBwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3MvYXBpIGRpcmVjdG9yeSBvciB0aGVcbiAqIERhdGFUYWJsZXMgc2l0ZVxuICovXG5cbi8vIEJ1dHRvbnMgZ3JvdXAgYW5kIGluZGl2aWR1YWwgYnV0dG9uIHNlbGVjdG9yXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCAnYnV0dG9ucygpJywgZnVuY3Rpb24gKCBncm91cCwgc2VsZWN0b3IgKSB7XG5cdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzZWxlY3RvciA9IGdyb3VwO1xuXHRcdGdyb3VwID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0dGhpcy5zZWxlY3Rvci5idXR0b25Hcm91cCA9IGdyb3VwO1xuXG5cdHZhciByZXMgPSB0aGlzLml0ZXJhdG9yKCB0cnVlLCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRpZiAoIGN0eC5fYnV0dG9ucyApIHtcblx0XHRcdHJldHVybiBCdXR0b25zLmJ1dHRvblNlbGVjdG9yKFxuXHRcdFx0XHRCdXR0b25zLmluc3RhbmNlU2VsZWN0b3IoIGdyb3VwLCBjdHguX2J1dHRvbnMgKSxcblx0XHRcdFx0c2VsZWN0b3Jcblx0XHRcdCk7XG5cdFx0fVxuXHR9LCB0cnVlICk7XG5cblx0cmVzLl9ncm91cFNlbGVjdG9yID0gZ3JvdXA7XG5cdHJldHVybiByZXM7XG59ICk7XG5cbi8vIEluZGl2aWR1YWwgYnV0dG9uIHNlbGVjdG9yXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCAnYnV0dG9uKCknLCBmdW5jdGlvbiAoIGdyb3VwLCBzZWxlY3RvciApIHtcblx0Ly8ganVzdCBydW4gYnV0dG9ucygpIGFuZCB0cnVuY2F0ZVxuXHR2YXIgYnV0dG9ucyA9IHRoaXMuYnV0dG9ucyggZ3JvdXAsIHNlbGVjdG9yICk7XG5cblx0aWYgKCBidXR0b25zLmxlbmd0aCA+IDEgKSB7XG5cdFx0YnV0dG9ucy5zcGxpY2UoIDEsIGJ1dHRvbnMubGVuZ3RoICk7XG5cdH1cblxuXHRyZXR1cm4gYnV0dG9ucztcbn0gKTtcblxuLy8gQWN0aXZlIGJ1dHRvbnNcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoICdidXR0b25zKCkuYWN0aXZlKCknLCAnYnV0dG9uKCkuYWN0aXZlKCknLCBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdGlmICggZmxhZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0XHRyZXR1cm4gc2V0Lmluc3QuYWN0aXZlKCBzZXQubm9kZSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHNldC5pbnN0LmFjdGl2ZSggc2V0Lm5vZGUsIGZsYWcgKTtcblx0fSApO1xufSApO1xuXG4vLyBHZXQgLyBzZXQgYnV0dG9uIGFjdGlvblxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCggJ2J1dHRvbnMoKS5hY3Rpb24oKScsICdidXR0b24oKS5hY3Rpb24oKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRpZiAoIGFjdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0XHRyZXR1cm4gc2V0Lmluc3QuYWN0aW9uKCBzZXQubm9kZSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHNldC5pbnN0LmFjdGlvbiggc2V0Lm5vZGUsIGFjdGlvbiApO1xuXHR9ICk7XG59ICk7XG5cbi8vIEVuYWJsZSAvIGRpc2FibGUgYnV0dG9uc1xuRGF0YVRhYmxlLkFwaS5yZWdpc3RlciggWydidXR0b25zKCkuZW5hYmxlKCknLCAnYnV0dG9uKCkuZW5hYmxlKCknXSwgZnVuY3Rpb24gKCBmbGFnICkge1xuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRzZXQuaW5zdC5lbmFibGUoIHNldC5ub2RlLCBmbGFnICk7XG5cdH0gKTtcbn0gKTtcblxuLy8gRGlzYWJsZSBidXR0b25zXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCBbJ2J1dHRvbnMoKS5kaXNhYmxlKCknLCAnYnV0dG9uKCkuZGlzYWJsZSgpJ10sIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0c2V0Lmluc3QuZGlzYWJsZSggc2V0Lm5vZGUgKTtcblx0fSApO1xufSApO1xuXG4vLyBHZXQgYnV0dG9uIG5vZGVzXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnYnV0dG9ucygpLm5vZGVzKCknLCAnYnV0dG9uKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIganEgPSAkKCk7XG5cblx0Ly8galF1ZXJ5IHdpbGwgYXV0b21hdGljYWxseSByZWR1Y2UgZHVwbGljYXRlcyB0byBhIHNpbmdsZSBlbnRyeVxuXHQkKCB0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdGpxID0ganEuYWRkKCBzZXQuaW5zdC5ub2RlKCBzZXQubm9kZSApICk7XG5cdH0gKSApO1xuXG5cdHJldHVybiBqcTtcbn0gKTtcblxuLy8gR2V0IC8gc2V0IGJ1dHRvbiBwcm9jZXNzaW5nIHN0YXRlXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnYnV0dG9ucygpLnByb2Nlc3NpbmcoKScsICdidXR0b24oKS5wcm9jZXNzaW5nKCknLCBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdGlmICggZmxhZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0XHRyZXR1cm4gc2V0Lmluc3QucHJvY2Vzc2luZyggc2V0Lm5vZGUgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRzZXQuaW5zdC5wcm9jZXNzaW5nKCBzZXQubm9kZSwgZmxhZyApO1xuXHR9ICk7XG59ICk7XG5cbi8vIEdldCAvIHNldCBidXR0b24gdGV4dCAoaS5lLiB0aGUgYnV0dG9uIGxhYmVscylcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoICdidXR0b25zKCkudGV4dCgpJywgJ2J1dHRvbigpLnRleHQoKScsIGZ1bmN0aW9uICggbGFiZWwgKSB7XG5cdGlmICggbGFiZWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdFx0cmV0dXJuIHNldC5pbnN0LnRleHQoIHNldC5ub2RlICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0c2V0Lmluc3QudGV4dCggc2V0Lm5vZGUsIGxhYmVsICk7XG5cdH0gKTtcbn0gKTtcblxuLy8gVHJpZ2dlciBhIGJ1dHRvbidzIGFjdGlvblxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCggJ2J1dHRvbnMoKS50cmlnZ2VyKCknLCAnYnV0dG9uKCkudHJpZ2dlcigpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRzZXQuaW5zdC5ub2RlKCBzZXQubm9kZSApLnRyaWdnZXIoICdjbGljaycgKTtcblx0fSApO1xufSApO1xuXG4vLyBCdXR0b24gcmVzb2x2ZXIgdG8gdGhlIHBvcG92ZXJcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b24oKS5wb3BvdmVyKCknLCBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHJldHVybiBzZXQuaW5zdC5fcG9wb3ZlciggY29udGVudCwgdGhpcy5idXR0b24odGhpc1swXS5ub2RlKSwgb3B0aW9ucyApO1xuXHR9ICk7XG59ICk7XG5cbi8vIEdldCB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCAnYnV0dG9ucygpLmNvbnRhaW5lcnMoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGpxID0gJCgpO1xuXHR2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cblx0Ly8gV2UgbmVlZCB0byB1c2UgdGhlIGdyb3VwIHNlbGVjdG9yIGRpcmVjdGx5LCBzaW5jZSBpZiB0aGVyZSBhcmUgbm8gYnV0dG9uc1xuXHQvLyB0aGUgcmVzdWx0IHNldCB3aWxsIGJlIGVtcHR5XG5cdHRoaXMuaXRlcmF0b3IoIHRydWUsICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGlmICggY3R4Ll9idXR0b25zICkge1xuXHRcdFx0dmFyIGluc3RzID0gQnV0dG9ucy5pbnN0YW5jZVNlbGVjdG9yKCBncm91cFNlbGVjdG9yLCBjdHguX2J1dHRvbnMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWluc3RzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRqcSA9IGpxLmFkZCggaW5zdHNbaV0uY29udGFpbmVyKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4ganE7XG59ICk7XG5cbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zKCkuY29udGFpbmVyKCknLCBmdW5jdGlvbiAoKSB7XG5cdC8vIEFQSSBsZXZlbCBvZiBuZXN0aW5nIGlzIGBidXR0b25zKClgIHNvIHdlIGNhbiB6aXAgaW50byB0aGUgY29udGFpbmVycyBtZXRob2Rcblx0cmV0dXJuIHRoaXMuY29udGFpbmVycygpLmVxKDApO1xufSApO1xuXG4vLyBBZGQgYSBuZXcgYnV0dG9uXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCAnYnV0dG9uKCkuYWRkKCknLCBmdW5jdGlvbiAoIGlkeCwgY29uZiApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHQvLyBEb24ndCB1c2UgYHRoaXNgIGFzIGl0IGNvdWxkIGJlIGVtcHR5IC0gc2VsZWN0IHRoZSBpbnN0YW5jZXMgZGlyZWN0bHlcblx0aWYgKCBjdHgubGVuZ3RoICkge1xuXHRcdHZhciBpbnN0ID0gQnV0dG9ucy5pbnN0YW5jZVNlbGVjdG9yKCB0aGlzLl9ncm91cFNlbGVjdG9yLCBjdHhbMF0uX2J1dHRvbnMgKTtcblxuXHRcdGlmICggaW5zdC5sZW5ndGggKSB7XG5cdFx0XHRpbnN0WzBdLmFkZCggY29uZiwgaWR4ICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXMuYnV0dG9uKCB0aGlzLl9ncm91cFNlbGVjdG9yLCBpZHggKTtcbn0gKTtcblxuLy8gRGVzdHJveSB0aGUgYnV0dG9uIHNldHMgc2VsZWN0ZWRcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zKCkuZGVzdHJveSgpJywgZnVuY3Rpb24gKCkge1xuXHR0aGlzLnBsdWNrKCAnaW5zdCcgKS51bmlxdWUoKS5lYWNoKCBmdW5jdGlvbiAoIGluc3QgKSB7XG5cdFx0aW5zdC5kZXN0cm95KCk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuLy8gUmVtb3ZlIGEgYnV0dG9uXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnYnV0dG9ucygpLnJlbW92ZSgpJywgJ2J1dHRvbnMoKS5yZW1vdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0dGhpcy5lYWNoKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRzZXQuaW5zdC5yZW1vdmUoIHNldC5ub2RlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuLy8gSW5mb3JtYXRpb24gYm94IHRoYXQgY2FuIGJlIHVzZWQgYnkgYnV0dG9uc1xudmFyIF9pbmZvVGltZXI7XG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCAnYnV0dG9ucy5pbmZvKCknLCBmdW5jdGlvbiAoIHRpdGxlLCBtZXNzYWdlLCB0aW1lICkge1xuXHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0aWYgKCB0aXRsZSA9PT0gZmFsc2UgKSB7XG5cdFx0dGhpcy5vZmYoJ2Rlc3Ryb3kuYnRuLWluZm8nKTtcblx0XHRfZmFkZU91dChcblx0XHRcdCQoJyNkYXRhdGFibGVzX2J1dHRvbnNfaW5mbycpLFxuXHRcdFx0NDAwLFxuXHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkKHRoaXMpLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdFx0Y2xlYXJUaW1lb3V0KCBfaW5mb1RpbWVyICk7XG5cdFx0X2luZm9UaW1lciA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlmICggX2luZm9UaW1lciApIHtcblx0XHRjbGVhclRpbWVvdXQoIF9pbmZvVGltZXIgKTtcblx0fVxuXG5cdGlmICggJCgnI2RhdGF0YWJsZXNfYnV0dG9uc19pbmZvJykubGVuZ3RoICkge1xuXHRcdCQoJyNkYXRhdGFibGVzX2J1dHRvbnNfaW5mbycpLnJlbW92ZSgpO1xuXHR9XG5cblx0dGl0bGUgPSB0aXRsZSA/ICc8aDI+Jyt0aXRsZSsnPC9oMj4nIDogJyc7XG5cblx0X2ZhZGVJbihcblx0XHQkKCc8ZGl2IGlkPVwiZGF0YXRhYmxlc19idXR0b25zX2luZm9cIiBjbGFzcz1cImR0LWJ1dHRvbi1pbmZvXCIvPicpXG5cdFx0XHQuaHRtbCggdGl0bGUgKVxuXHRcdFx0LmFwcGVuZCggJCgnPGRpdi8+JylbIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/ICdodG1sJyA6ICdhcHBlbmQnIF0oIG1lc3NhZ2UgKSApXG5cdFx0XHQuY3NzKCAnZGlzcGxheScsICdub25lJyApXG5cdFx0XHQuYXBwZW5kVG8oICdib2R5JyApXG5cdCk7XG5cblx0aWYgKCB0aW1lICE9PSB1bmRlZmluZWQgJiYgdGltZSAhPT0gMCApIHtcblx0XHRfaW5mb1RpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5idXR0b25zLmluZm8oIGZhbHNlICk7XG5cdFx0fSwgdGltZSApO1xuXHR9XG5cblx0dGhpcy5vbignZGVzdHJveS5idG4taW5mbycsIGZ1bmN0aW9uICgpIHtcblx0XHR0aGF0LmJ1dHRvbnMuaW5mbyhmYWxzZSk7XG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG4vLyBHZXQgZGF0YSBmcm9tIHRoZSB0YWJsZSBmb3IgZXhwb3J0IC0gdGhpcyBpcyBjb21tb24gdG8gYSBudW1iZXIgb2YgcGx1Zy1pblxuLy8gYnV0dG9ucyBzbyBpdCBpcyBpbmNsdWRlZCBpbiB0aGUgQnV0dG9ucyBjb3JlIGxpYnJhcnlcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zLmV4cG9ydERhdGEoKScsIGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoICkge1xuXHRcdHJldHVybiBfZXhwb3J0RGF0YSggbmV3IERhdGFUYWJsZS5BcGkoIHRoaXMuY29udGV4dFswXSApLCBvcHRpb25zICk7XG5cdH1cbn0gKTtcblxuLy8gR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBleHBvcnQgdGhhdCBpcyBjb21tb24gdG8gbWFueSBvZiB0aGUgZXhwb3J0IGRhdGFcbi8vIHR5cGVzIChEUlkpXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCAnYnV0dG9ucy5leHBvcnRJbmZvKCknLCBmdW5jdGlvbiAoIGNvbmYgKSB7XG5cdGlmICggISBjb25mICkge1xuXHRcdGNvbmYgPSB7fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0ZmlsZW5hbWU6IF9maWxlbmFtZSggY29uZiApLFxuXHRcdHRpdGxlOiBfdGl0bGUoIGNvbmYgKSxcblx0XHRtZXNzYWdlVG9wOiBfbWVzc2FnZSh0aGlzLCBjb25mLm1lc3NhZ2UgfHwgY29uZi5tZXNzYWdlVG9wLCAndG9wJyksXG5cdFx0bWVzc2FnZUJvdHRvbTogX21lc3NhZ2UodGhpcywgY29uZi5tZXNzYWdlQm90dG9tLCAnYm90dG9tJylcblx0fTtcbn0gKTtcblxuXG5cbi8qKlxuICogR2V0IHRoZSBmaWxlIG5hbWUgZm9yIGFuIGV4cG9ydGVkIGZpbGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9XHRjb25maWcgQnV0dG9uIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jRXh0ZW5zaW9uIEluY2x1ZGUgdGhlIGZpbGUgbmFtZSBleHRlbnNpb25cbiAqL1xudmFyIF9maWxlbmFtZSA9IGZ1bmN0aW9uICggY29uZmlnIClcbntcblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0dmFyIGZpbGVuYW1lID0gY29uZmlnLmZpbGVuYW1lID09PSAnKicgJiYgY29uZmlnLnRpdGxlICE9PSAnKicgJiYgY29uZmlnLnRpdGxlICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLnRpdGxlICE9PSBudWxsICYmIGNvbmZpZy50aXRsZSAhPT0gJycgP1xuXHRcdGNvbmZpZy50aXRsZSA6XG5cdFx0Y29uZmlnLmZpbGVuYW1lO1xuXG5cdGlmICggdHlwZW9mIGZpbGVuYW1lID09PSAnZnVuY3Rpb24nICkge1xuXHRcdGZpbGVuYW1lID0gZmlsZW5hbWUoKTtcblx0fVxuXG5cdGlmICggZmlsZW5hbWUgPT09IHVuZGVmaW5lZCB8fCBmaWxlbmFtZSA9PT0gbnVsbCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICggZmlsZW5hbWUuaW5kZXhPZiggJyonICkgIT09IC0xICkge1xuXHRcdGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSggJyonLCAkKCdoZWFkID4gdGl0bGUnKS50ZXh0KCkgKS50cmltKCk7XG5cdH1cblxuXHQvLyBTdHJpcCBjaGFyYWN0ZXJzIHdoaWNoIHRoZSBPUyB3aWxsIG9iamVjdCB0b1xuXHRmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05X1xcdTAwQTEtXFx1RkZGRlxcLixcXC1fICFcXChcXCldL2csIFwiXCIpO1xuXG5cdHZhciBleHRlbnNpb24gPSBfc3RyaW5nT3JGdW5jdGlvbiggY29uZmlnLmV4dGVuc2lvbiApO1xuXHRpZiAoICEgZXh0ZW5zaW9uICkge1xuXHRcdGV4dGVuc2lvbiA9ICcnO1xuXHR9XG5cblx0cmV0dXJuIGZpbGVuYW1lICsgZXh0ZW5zaW9uO1xufTtcblxuLyoqXG4gKiBTaW1wbHkgdXRpbGl0eSBtZXRob2QgdG8gYWxsb3cgcGFyYW1ldGVycyB0byBiZSBnaXZlbiBhcyBhIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHt1bmRlZmluZWR8c3RyaW5nfGZ1bmN0aW9ufSBvcHRpb24gT3B0aW9uXG4gKiBAcmV0dXJuIHtudWxsfHN0cmluZ30gUmVzb2x2ZWQgdmFsdWVcbiAqL1xudmFyIF9zdHJpbmdPckZ1bmN0aW9uID0gZnVuY3Rpb24gKCBvcHRpb24gKVxue1xuXHRpZiAoIG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4gb3B0aW9uKCk7XG5cdH1cblx0cmV0dXJuIG9wdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0aXRsZSBmb3IgYW4gZXhwb3J0ZWQgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXHRCdXR0b24gY29uZmlndXJhdGlvblxuICovXG52YXIgX3RpdGxlID0gZnVuY3Rpb24gKCBjb25maWcgKVxue1xuXHR2YXIgdGl0bGUgPSBfc3RyaW5nT3JGdW5jdGlvbiggY29uZmlnLnRpdGxlICk7XG5cblx0cmV0dXJuIHRpdGxlID09PSBudWxsID9cblx0XHRudWxsIDogdGl0bGUuaW5kZXhPZiggJyonICkgIT09IC0xID9cblx0XHRcdHRpdGxlLnJlcGxhY2UoICcqJywgJCgnaGVhZCA+IHRpdGxlJykudGV4dCgpIHx8ICdFeHBvcnRlZCBkYXRhJyApIDpcblx0XHRcdHRpdGxlO1xufTtcblxudmFyIF9tZXNzYWdlID0gZnVuY3Rpb24gKCBkdCwgb3B0aW9uLCBwb3NpdGlvbiApXG57XG5cdHZhciBtZXNzYWdlID0gX3N0cmluZ09yRnVuY3Rpb24oIG9wdGlvbiApO1xuXHRpZiAoIG1lc3NhZ2UgPT09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgY2FwdGlvbiA9ICQoJ2NhcHRpb24nLCBkdC50YWJsZSgpLmNvbnRhaW5lcigpKS5lcSgwKTtcblx0aWYgKCBtZXNzYWdlID09PSAnKicgKSB7XG5cdFx0dmFyIHNpZGUgPSBjYXB0aW9uLmNzcyggJ2NhcHRpb24tc2lkZScgKTtcblx0XHRpZiAoIHNpZGUgIT09IHBvc2l0aW9uICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhcHRpb24ubGVuZ3RoID9cblx0XHRcdGNhcHRpb24udGV4dCgpIDpcblx0XHRcdCcnO1xuXHR9XG5cblx0cmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5cblxuXG52YXIgX2V4cG9ydFRleHRhcmVhID0gJCgnPHRleHRhcmVhLz4nKVswXTtcbnZhciBfZXhwb3J0RGF0YSA9IGZ1bmN0aW9uICggZHQsIGluT3B0cyApXG57XG5cdHZhciBjb25maWcgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHtcblx0XHRyb3dzOiAgICAgICAgICAgbnVsbCxcblx0XHRjb2x1bW5zOiAgICAgICAgJycsXG5cdFx0bW9kaWZpZXI6ICAgICAgIHtcblx0XHRcdHNlYXJjaDogJ2FwcGxpZWQnLFxuXHRcdFx0b3JkZXI6ICAnYXBwbGllZCdcblx0XHR9LFxuXHRcdG9ydGhvZ29uYWw6ICAgICAnZGlzcGxheScsXG5cdFx0c3RyaXBIdG1sOiAgICAgIHRydWUsXG5cdFx0c3RyaXBOZXdsaW5lczogIHRydWUsXG5cdFx0ZGVjb2RlRW50aXRpZXM6IHRydWUsXG5cdFx0dHJpbTogICAgICAgICAgIHRydWUsXG5cdFx0Zm9ybWF0OiAgICAgICAgIHtcblx0XHRcdGhlYWRlcjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRyZXR1cm4gQnV0dG9ucy5zdHJpcERhdGEoIGQsIGNvbmZpZyApO1xuXHRcdFx0fSxcblx0XHRcdGZvb3RlcjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRyZXR1cm4gQnV0dG9ucy5zdHJpcERhdGEoIGQsIGNvbmZpZyApO1xuXHRcdFx0fSxcblx0XHRcdGJvZHk6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0cmV0dXJuIEJ1dHRvbnMuc3RyaXBEYXRhKCBkLCBjb25maWcgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGN1c3RvbWl6ZURhdGE6IG51bGxcblx0fSwgaW5PcHRzICk7XG5cblx0dmFyIGhlYWRlciA9IGR0LmNvbHVtbnMoIGNvbmZpZy5jb2x1bW5zICkuaW5kZXhlcygpLm1hcCggZnVuY3Rpb24gKGlkeCkge1xuXHRcdHZhciBlbCA9IGR0LmNvbHVtbiggaWR4ICkuaGVhZGVyKCk7XG5cdFx0cmV0dXJuIGNvbmZpZy5mb3JtYXQuaGVhZGVyKCBlbC5pbm5lckhUTUwsIGlkeCwgZWwgKTtcblx0fSApLnRvQXJyYXkoKTtcblxuXHR2YXIgZm9vdGVyID0gZHQudGFibGUoKS5mb290ZXIoKSA/XG5cdFx0ZHQuY29sdW1ucyggY29uZmlnLmNvbHVtbnMgKS5pbmRleGVzKCkubWFwKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHR2YXIgZWwgPSBkdC5jb2x1bW4oIGlkeCApLmZvb3RlcigpO1xuXHRcdFx0cmV0dXJuIGNvbmZpZy5mb3JtYXQuZm9vdGVyKCBlbCA/IGVsLmlubmVySFRNTCA6ICcnLCBpZHgsIGVsICk7XG5cdFx0fSApLnRvQXJyYXkoKSA6XG5cdFx0bnVsbDtcblx0XG5cdC8vIElmIFNlbGVjdCBpcyBhdmFpbGFibGUgb24gdGhpcyB0YWJsZSwgYW5kIGFueSByb3dzIGFyZSBzZWxlY3RlZCwgbGltaXQgdGhlIGV4cG9ydFxuXHQvLyB0byB0aGUgc2VsZWN0ZWQgcm93cy4gSWYgbm8gcm93cyBhcmUgc2VsZWN0ZWQsIGFsbCByb3dzIHdpbGwgYmUgZXhwb3J0ZWQuIFNwZWNpZnlcblx0Ly8gYSBgc2VsZWN0ZWRgIG1vZGlmaWVyIHRvIGNvbnRyb2wgZGlyZWN0bHkuXG5cdHZhciBtb2RpZmllciA9ICQuZXh0ZW5kKCB7fSwgY29uZmlnLm1vZGlmaWVyICk7XG5cdGlmICggZHQuc2VsZWN0ICYmIHR5cGVvZiBkdC5zZWxlY3QuaW5mbyA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2RpZmllci5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGlmICggZHQucm93cyggY29uZmlnLnJvd3MsICQuZXh0ZW5kKCB7IHNlbGVjdGVkOiB0cnVlIH0sIG1vZGlmaWVyICkgKS5hbnkoKSApIHtcblx0XHRcdCQuZXh0ZW5kKCBtb2RpZmllciwgeyBzZWxlY3RlZDogdHJ1ZSB9IClcblx0XHR9XG5cdH1cblxuXHR2YXIgcm93SW5kZXhlcyA9IGR0LnJvd3MoIGNvbmZpZy5yb3dzLCBtb2RpZmllciApLmluZGV4ZXMoKS50b0FycmF5KCk7XG5cdHZhciBzZWxlY3RlZENlbGxzID0gZHQuY2VsbHMoIHJvd0luZGV4ZXMsIGNvbmZpZy5jb2x1bW5zICk7XG5cdHZhciBjZWxscyA9IHNlbGVjdGVkQ2VsbHNcblx0XHQucmVuZGVyKCBjb25maWcub3J0aG9nb25hbCApXG5cdFx0LnRvQXJyYXkoKTtcblx0dmFyIGNlbGxOb2RlcyA9IHNlbGVjdGVkQ2VsbHNcblx0XHQubm9kZXMoKVxuXHRcdC50b0FycmF5KCk7XG5cblx0dmFyIGNvbHVtbnMgPSBoZWFkZXIubGVuZ3RoO1xuXHR2YXIgcm93cyA9IGNvbHVtbnMgPiAwID8gY2VsbHMubGVuZ3RoIC8gY29sdW1ucyA6IDA7XG5cdHZhciBib2R5ID0gW107XG5cdHZhciBjZWxsQ291bnRlciA9IDA7XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPXJvd3MgOyBpPGllbiA7IGkrKyApIHtcblx0XHR2YXIgcm93ID0gWyBjb2x1bW5zIF07XG5cblx0XHRmb3IgKCB2YXIgaj0wIDsgajxjb2x1bW5zIDsgaisrICkge1xuXHRcdFx0cm93W2pdID0gY29uZmlnLmZvcm1hdC5ib2R5KCBjZWxsc1sgY2VsbENvdW50ZXIgXSwgaSwgaiwgY2VsbE5vZGVzWyBjZWxsQ291bnRlciBdICk7XG5cdFx0XHRjZWxsQ291bnRlcisrO1xuXHRcdH1cblxuXHRcdGJvZHlbaV0gPSByb3c7XG5cdH1cblxuXHR2YXIgZGF0YSA9IHtcblx0XHRoZWFkZXI6IGhlYWRlcixcblx0XHRmb290ZXI6IGZvb3Rlcixcblx0XHRib2R5OiAgIGJvZHlcblx0fTtcblxuXHRpZiAoIGNvbmZpZy5jdXN0b21pemVEYXRhICkge1xuXHRcdGNvbmZpZy5jdXN0b21pemVEYXRhKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn07XG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIERhdGFUYWJsZXMgaW50ZXJmYWNlXG4gKi9cblxuLy8gQXR0YWNoIHRvIERhdGFUYWJsZXMgb2JqZWN0cyBmb3IgZ2xvYmFsIGFjY2Vzc1xuJC5mbi5kYXRhVGFibGUuQnV0dG9ucyA9IEJ1dHRvbnM7XG4kLmZuLkRhdGFUYWJsZS5CdXR0b25zID0gQnV0dG9ucztcblxuXG5cbi8vIERhdGFUYWJsZXMgY3JlYXRpb24gLSBjaGVjayBpZiB0aGUgYnV0dG9ucyBoYXZlIGJlZW4gZGVmaW5lZCBmb3IgdGhpcyB0YWJsZSxcbi8vIHRoZXkgd2lsbCBoYXZlIGJlZW4gaWYgdGhlIGBCYCBvcHRpb24gd2FzIHVzZWQgaW4gYGRvbWAsIG90aGVyd2lzZSB3ZSBzaG91bGRcbi8vIGNyZWF0ZSB0aGUgYnV0dG9ucyBpbnN0YW5jZSBoZXJlIHNvIHRoZXkgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIGRvY3VtZW50XG4vLyB1c2luZyB0aGUgQVBJLiBMaXN0ZW4gZm9yIGBpbml0YCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHByZSAxLjEwLjEwLCBidXQgdG9cbi8vIGJlIHJlbW92ZWQgaW4gZnV0dXJlLlxuJChkb2N1bWVudCkub24oICdpbml0LmR0IHBsdWdpbi1pbml0LmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzKSB7XG5cdGlmICggZS5uYW1lc3BhY2UgIT09ICdkdCcgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIG9wdHMgPSBzZXR0aW5ncy5vSW5pdC5idXR0b25zIHx8IERhdGFUYWJsZS5kZWZhdWx0cy5idXR0b25zO1xuXG5cdGlmICggb3B0cyAmJiAhIHNldHRpbmdzLl9idXR0b25zICkge1xuXHRcdG5ldyBCdXR0b25zKCBzZXR0aW5ncywgb3B0cyApLmNvbnRhaW5lcigpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIF9pbml0ICggc2V0dGluZ3MsIG9wdGlvbnMgKSB7XG5cdHZhciBhcGkgPSBuZXcgRGF0YVRhYmxlLkFwaSggc2V0dGluZ3MgKTtcblx0dmFyIG9wdHMgPSBvcHRpb25zXG5cdFx0PyBvcHRpb25zXG5cdFx0OiBhcGkuaW5pdCgpLmJ1dHRvbnMgfHwgRGF0YVRhYmxlLmRlZmF1bHRzLmJ1dHRvbnM7XG5cblx0cmV0dXJuIG5ldyBCdXR0b25zKCBhcGksIG9wdHMgKS5jb250YWluZXIoKTtcbn1cblxuLy8gRGF0YVRhYmxlcyBgZG9tYCBmZWF0dXJlIG9wdGlvblxuRGF0YVRhYmxlLmV4dC5mZWF0dXJlLnB1c2goIHtcblx0Zm5Jbml0OiBfaW5pdCxcblx0Y0ZlYXR1cmU6IFwiQlwiXG59ICk7XG5cbi8vIERhdGFUYWJsZXMgMiBsYXlvdXQgZmVhdHVyZVxuaWYgKCBEYXRhVGFibGUuZXh0LmZlYXR1cmVzICkge1xuXHREYXRhVGFibGUuZXh0LmZlYXR1cmVzLnJlZ2lzdGVyKCAnYnV0dG9ucycsIF9pbml0ICk7XG59XG5cblxucmV0dXJuIEJ1dHRvbnM7XG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=